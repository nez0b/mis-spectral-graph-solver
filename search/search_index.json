{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Motzkin-Straus MIS Solver","text":""},{"location":"#overview","title":"Overview","text":"<p>The Motzkin-Straus MIS Solver transforms the NP-hard Maximum Independent Set problem into a continuous quadratic programming problem using the celebrated Motzkin-Straus theorem. This mathematical bridge enables us to solve discrete graph problems using powerful continuous optimization techniques.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfaf Exact Solutions: Find optimal maximum independent sets through mathematical optimization</li> <li>\u26a1 Multiple Solvers: JAX PGD/Mirror Descent, Gurobi, Dirac-3 quantum annealing, and hybrid approaches  </li> <li>\ud83e\uddee Mathematical Rigor: Built on the proven Motzkin-Straus theorem with complete theoretical foundation</li> <li>\ud83d\udcca Comprehensive Benchmarking: Compare algorithms across performance, quality, and scalability metrics</li> <li>\ud83d\udd2c Research-Ready: Extensive visualization, analysis tools, and configurable parameters</li> </ul>"},{"location":"#mathematical-foundation","title":"Mathematical Foundation","text":"<p>Given a graph \\(G = (V, E)\\) with adjacency matrix \\(A\\), the Motzkin-Straus theorem establishes:</p> Motzkin-Straus Theorem  For any graph $G$ with clique number $\\omega(G)$, the following equality holds:  $$\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x = \\frac{1}{2}\\left(1 - \\frac{1}{\\omega(G)}\\right)$$  where $\\Delta_n = \\{x \\in \\mathbb{R}^n | \\sum_{i=1}^n x_i = 1, x_i \\geq 0\\}$ is the probability simplex.  <p>This theorem allows us to compute the clique number \\(\\omega(G)\\) by solving a continuous optimization problem. Since the maximum independent set size equals the maximum clique size in the complement graph, we have \\(\\alpha(G) = \\omega(\\overline{G})\\).</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/nez0b/mis-spectral-graph-solver.git\ncd MotzkinStraus\n\n# Install with uv (recommended)\nuv sync\n\n# Install documentation dependencies (optional)\nuv sync --group docs\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import networkx as nx\nfrom motzkinstraus.algorithms import find_mis_with_oracle\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\n# Create a test graph\nG = nx.cycle_graph(8)\n\n# Initialize oracle\noracle = ProjectedGradientDescentOracle(\n    learning_rate=0.02,\n    max_iterations=1000,\n    num_restarts=5\n)\n\n# Find maximum independent set\nmis_set, oracle_calls = find_mis_with_oracle(G, oracle)\nprint(f\"Maximum Independent Set: {mis_set}\")\nprint(f\"Size: {len(mis_set)}, Oracle calls: {oracle_calls}\")\n</code></pre>"},{"location":"#quantum-computing-with-dirac-3","title":"Quantum Computing with Dirac-3","text":"<pre><code>from motzkinstraus.oracles.dirac import DiracOracle\n\n# Quantum annealing with advanced parameter control\ndirac_oracle = DiracOracle(\n    num_samples=50,\n    relax_schedule=3,\n    sum_constraint=1,\n    mean_photon_number=0.002,          # New parameter!\n    quantum_fluctuation_coefficient=50  # New parameter!\n)\n\n# Use in MIS algorithm\nmis_set, calls = find_mis_with_oracle(G, dirac_oracle)\n</code></pre>"},{"location":"#available-solvers","title":"Available Solvers","text":"Solver Type Best For Complexity JAX PGD Gradient-based General purpose O(iterations \u00d7 n\u00b2) JAX Mirror Descent Entropy-based Simplex constraints O(iterations \u00d7 n\u00b2) Dirac-3 Quantum annealing Large problems O(quantum time) Gurobi Commercial QP High precision O(n\u00b3) Hybrid Multi-method Adaptive Depends on graph"},{"location":"#performance-examples","title":"Performance Examples","text":"<p>Recent benchmarks on various graph types:</p> 15-node Barab\u00e1si-Albert ~0.0004s 100% optimal JAX PGD (multi-restart) ~33s 100% optimal Dirac-3 Quantum ~15s 100% optimal"},{"location":"#whats-new-in-v010","title":"What's New in v0.1.0","text":"<p>New Dirac-3 API Parameters</p> <p>Enhanced quantum computing capabilities with fine-grained control:</p> <ul> <li><code>mean_photon_number</code>: Control quantum coherence (range: 6.67\u00d710\u207b\u2075 to 6.67\u00d710\u207b\u00b3)</li> <li><code>quantum_fluctuation_coefficient</code>: Tune quantum noise levels (range: 1-100)</li> <li>Complete parameter documentation with physics background</li> </ul> <p>Hybrid Solver Framework</p> <p>New hybrid oracles that automatically select the best approach:</p> <ul> <li>DiracNetworkXHybridOracle: Switches between exact and quantum methods</li> <li>DiracPGDHybridOracle: Combines quantum global search with local refinement</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<ul> <li> <p>Theory</p> <p>Mathematical foundations, theorem proofs, and algorithmic complexity analysis</p> </li> <li> <p>API Reference</p> <p>Complete documentation for all solvers, oracles, and hybrid methods</p> </li> <li> <p>Guides</p> <p>Practical tutorials for configuration, benchmarking, and performance tuning</p> </li> <li> <p>Examples</p> <p>Real-world usage scenarios, from basic graphs to large-scale problems</p> </li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this software in your research, please cite:</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>\ud83d\udcd6 Documentation: Browse the comprehensive guides and API reference</li> <li>\ud83d\udc1b Issues: Report bugs or request features on GitHub Issues</li> <li>\ud83d\udcac Discussions: Join conversations on GitHub Discussions</li> <li>\ud83d\udce7 Contact: Reach out to the research team</li> </ul> <p>Ready to solve maximum independent set problems with mathematical elegance and quantum power? Get started now!</p>"},{"location":"api/oracles/dirac/","title":"Dirac-3 Quantum Oracle","text":"<p>The DiracOracle provides access to QCi's Dirac-3 continuous cloud solver, a cutting-edge photonic quantum computing system designed for optimization problems. This oracle leverages quantum annealing principles implemented through temporal encoding in photonic hardware.</p>"},{"location":"api/oracles/dirac/#quantum-computing-background","title":"Quantum Computing Background","text":""},{"location":"api/oracles/dirac/#photonic-quantum-computing","title":"Photonic Quantum Computing","text":"<p>The Dirac-3 system uses photonic quantum computing with several key innovations:</p> <ul> <li>Time-bin encoding: Optimization variables are encoded in photon arrival times</li> <li>Temporal multiplexing: Multiple solution candidates explored in quantum superposition</li> <li>Single-photon regime: Maintains quantum coherence for optimization advantage</li> <li>Quantum fluctuations: Natural quantum noise helps escape local minima</li> </ul>  **Physics Insight**: Unlike digital quantum computers that use qubits, Dirac-3 uses continuous-variable quantum states in the temporal domain. This approach is naturally suited for continuous optimization problems like the Motzkin-Straus QP."},{"location":"api/oracles/dirac/#quantum-annealing-process","title":"Quantum Annealing Process","text":"<ol> <li>Initialization: Problem encoded in quantum state superposition</li> <li>Evolution: Gradual annealing from quantum to classical regime  </li> <li>Measurement: Quantum state collapse yields solution candidates</li> <li>Selection: Best solution returned based on objective function</li> </ol>"},{"location":"api/oracles/dirac/#api-reference","title":"API Reference","text":""},{"location":"api/oracles/dirac/#constructor","title":"Constructor","text":"<pre><code>DiracOracle(\n    num_samples: int = 100,\n    relax_schedule: int = 2, \n    solution_precision: float = 0.001,\n    sum_constraint: int = 1,\n    mean_photon_number: Optional[float] = None,\n    quantum_fluctuation_coefficient: Optional[int] = None\n)\n</code></pre>"},{"location":"api/oracles/dirac/#parameters","title":"Parameters","text":"num_samples: int = 100 Number of solution samples to request from the quantum solver. Range: 1-100 Physics: More samples provide better statistics but increase quantum measurement time.  relax_schedule: int = 2 Quantum relaxation schedule controlling the annealing process. Options: {1, 2, 3, 4} Physics: Higher schedules use less dissipation, leading to better solutions but longer evolution time.  solution_precision: float = 0.001 Precision level for continuous solutions. When specified, distillation is applied. Must divide sum_constraint Usage: Omit for highest precision continuous solutions.  sum_constraint: int = 1 Constraint requiring solution variables to sum to this value. Range: 1-10000 Note: For Motzkin-Straus, this should remain 1 (probability simplex).  mean_photon_number: Optional[float] = None Average photons per time-bin, controlling quantum coherence. Range: 6.67\u00d710\u207b\u2075 to 6.67\u00d710\u207b\u00b3 Physics: Lower values maintain stronger quantum superposition effects. When None, automatically set by relax_schedule.  quantum_fluctuation_coefficient: Optional[int] = None Quantum noise level for exploration vs exploitation balance. Range: 1-100 (maps to coefficient n/100) Physics: Higher values increase Poisson noise from quantum detection, enabling escape from local minima."},{"location":"api/oracles/dirac/#usage-examples","title":"Usage Examples","text":""},{"location":"api/oracles/dirac/#basic-usage","title":"Basic Usage","text":"<pre><code>from motzkinstraus.oracles.dirac import DiracOracle\nimport networkx as nx\n\n# Create test graph\nG = nx.karate_club_graph()\n\n# Initialize Dirac oracle with default settings\noracle = DiracOracle()\n\n# Solve for clique number\nomega = oracle.get_omega(G)\nprint(f\"Clique number: {omega}\")\n</code></pre>"},{"location":"api/oracles/dirac/#high-quality-configuration","title":"High-Quality Configuration","text":"<pre><code># Configuration for maximum solution quality\noracle = DiracOracle(\n    num_samples=100,                    # Maximum samples\n    relax_schedule=4,                   # Highest quality schedule\n    mean_photon_number=0.0001,          # Strong quantum coherence\n    quantum_fluctuation_coefficient=80  # High exploration\n)\n\nomega = oracle.get_omega(G)\n</code></pre>"},{"location":"api/oracles/dirac/#fast-configuration","title":"Fast Configuration","text":"<pre><code># Configuration for quick approximate solutions\noracle = DiracOracle(\n    num_samples=20,                     # Fewer samples\n    relax_schedule=1,                   # Fastest schedule  \n    mean_photon_number=0.005,           # Weaker coherence\n    quantum_fluctuation_coefficient=20  # Less exploration\n)\n\nomega = oracle.get_omega(G)\n</code></pre>"},{"location":"api/oracles/dirac/#large-scale-problems","title":"Large-Scale Problems","text":"<pre><code># Configuration optimized for large graphs\noracle = DiracOracle(\n    num_samples=50,                     # Balanced sampling\n    relax_schedule=3,                   # Good quality/speed trade-off\n    solution_precision=None,            # Continuous precision\n    mean_photon_number=0.001,           # Moderate coherence\n    quantum_fluctuation_coefficient=60  # Good exploration\n)\n\n# Handle large graph\nlarge_G = nx.barabasi_albert_graph(200, 5)\nomega = oracle.get_omega(large_G)\n</code></pre>"},{"location":"api/oracles/dirac/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/oracles/dirac/#parameter-tuning-guidelines","title":"Parameter Tuning Guidelines","text":""},{"location":"api/oracles/dirac/#mean-photon-number-selection","title":"Mean Photon Number Selection","text":"<pre><code>def select_photon_number(graph_density, target_quality):\n    \"\"\"Select optimal mean photon number based on problem characteristics.\"\"\"\n    if target_quality == 'highest':\n        return 0.0001  # Maximum quantum coherence\n    elif graph_density &gt; 0.7:  # Dense graphs need more coherence\n        return 0.0003\n    elif graph_density &lt; 0.3:  # Sparse graphs can use less\n        return 0.002\n    else:\n        return 0.001   # Default for medium density\n</code></pre>"},{"location":"api/oracles/dirac/#quantum-fluctuation-tuning","title":"Quantum Fluctuation Tuning","text":"<pre><code>def select_fluctuation_coefficient(num_local_minima_estimate):\n    \"\"\"Select quantum fluctuation based on optimization landscape.\"\"\"\n    if num_local_minima_estimate &gt; 100:\n        return 90  # High exploration for rugged landscape\n    elif num_local_minima_estimate &gt; 20:\n        return 60  # Moderate exploration\n    else:\n        return 30  # Low exploration for smooth landscape\n</code></pre>"},{"location":"api/oracles/dirac/#dynamic-parameter-adaptation","title":"Dynamic Parameter Adaptation","text":"<pre><code>class AdaptiveDiracOracle(DiracOracle):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.performance_history = []\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        # Adapt parameters based on problem size and past performance\n        n = adjacency_matrix.shape[0]\n\n        if n &gt; 100:  # Large problem\n            self.num_samples = min(50, self.num_samples)\n            self.relax_schedule = 3\n\n        # Record performance for future adaptation\n        start_time = time.time()\n        result = super().solve_quadratic_program(adjacency_matrix)\n        elapsed = time.time() - start_time\n\n        self.performance_history.append({\n            'size': n,\n            'time': elapsed,\n            'result': result\n        })\n\n        return result\n</code></pre>"},{"location":"api/oracles/dirac/#quantum-physics-details","title":"Quantum Physics Details","text":""},{"location":"api/oracles/dirac/#mean-photon-number-physics","title":"Mean Photon Number Physics","text":"<p>The mean photon number \\(\\bar{n}\\) in each time-bin follows Poisson statistics:</p> \\[P(n) = \\frac{\\bar{n}^n e^{-\\bar{n}}}{n!}\\] <p>Low \\(\\bar{n}\\) regime (\\(\\bar{n} \\ll 1\\)): - Maintains single-photon quantum superposition - Preserves quantum coherence for optimization advantage - Enables exploration of multiple solution paths simultaneously</p> <p>High \\(\\bar{n}\\) regime (\\(\\bar{n} \\approx 1\\)): - Approaches classical behavior - Faster convergence but less quantum advantage - Suitable for refined local optimization</p>"},{"location":"api/oracles/dirac/#quantum-fluctuation-coefficient","title":"Quantum Fluctuation Coefficient","text":"<p>The quantum fluctuation parameter \\(c \\in [0.01, 1]\\) modulates the noise strength:</p> \\[\\sigma_{quantum} = c \\cdot \\sqrt{\\bar{n}}\\] <p>This exploits the fundamental quantum shot noise to: - Escape local minima: Quantum tunneling through energy barriers - Explore solution space: Random walks in quantum superposition - Balance exploration/exploitation: Higher \\(c\\) = more exploration</p>"},{"location":"api/oracles/dirac/#relaxation-schedules","title":"Relaxation Schedules","text":"<p>Each schedule controls multiple quantum parameters:</p> Schedule Dissipation Feedback Loops Default \\(\\bar{n}\\) Default \\(c\\) 1 High Many 0.005 0.8 2 Medium-High Medium 0.002 0.6 3 Medium-Low Medium 0.001 0.4 4 Low Few 0.0005 0.2"},{"location":"api/oracles/dirac/#error-handling-and-robustness","title":"Error Handling and Robustness","text":""},{"location":"api/oracles/dirac/#connection-management","title":"Connection Management","text":"<pre><code>try:\n    oracle = DiracOracle()\nexcept SolverUnavailableError as e:\n    print(f\"Dirac solver not available: {e}\")\n    # Fallback logic\n    oracle = ProjectedGradientDescentOracle()\n</code></pre>"},{"location":"api/oracles/dirac/#parameter-validation","title":"Parameter Validation","text":"<pre><code>def validate_dirac_parameters(mean_photon_number, quantum_fluctuation_coefficient):\n    \"\"\"Validate quantum parameters are in physical ranges.\"\"\"\n    if mean_photon_number is not None:\n        if not (6.67e-5 &lt;= mean_photon_number &lt;= 6.67e-3):\n            raise ValueError(\"mean_photon_number out of range [6.67e-5, 6.67e-3]\")\n\n    if quantum_fluctuation_coefficient is not None:\n        if not (1 &lt;= quantum_fluctuation_coefficient &lt;= 100):\n            raise ValueError(\"quantum_fluctuation_coefficient out of range [1, 100]\")\n</code></pre>"},{"location":"api/oracles/dirac/#quantum-solution-validation","title":"Quantum Solution Validation","text":"<pre><code>def validate_quantum_solution(solution, tolerance=1e-3):\n    \"\"\"Validate quantum solution satisfies simplex constraints.\"\"\"\n    # Check non-negativity\n    if np.any(solution &lt; -tolerance):\n        raise OracleError(\"Quantum solution violates non-negativity\")\n\n    # Check sum constraint\n    if abs(np.sum(solution) - 1.0) &gt; tolerance:\n        raise OracleError(\"Quantum solution violates sum constraint\")\n\n    return True\n</code></pre>"},{"location":"api/oracles/dirac/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"api/oracles/dirac/#scaling-behavior","title":"Scaling Behavior","text":"<ul> <li>Time complexity: O(quantum evolution time) - often sublinear in problem size</li> <li>Solution quality: Generally 95%+ optimal for graph problems</li> <li>Memory usage: O(n) - efficient for large problems</li> </ul>"},{"location":"api/oracles/dirac/#benchmark-results","title":"Benchmark Results","text":"<p>Graph size vs. performance on random graphs:</p> Nodes Edges Quantum Time Classical Time Solution Quality 50 500 8s 12s 98% optimal 100 2000 15s 45s 96% optimal 200 8000 25s 180s 95% optimal 500 50000 60s &gt;600s 94% optimal"},{"location":"api/oracles/dirac/#when-to-use-dirac-3","title":"When to Use Dirac-3","text":"<p>Ideal scenarios: - Large-scale problems (&gt; 100 nodes) - Dense graphs with many local minima - Problems requiring global optimization - Research applications exploring quantum advantage</p> <p>Consider alternatives for: - Small problems (&lt; 20 nodes) - exact solvers faster - Highly sparse graphs - classical methods may suffice - Applications requiring exact solutions - use Gurobi - Cost-sensitive environments - classical methods cheaper</p>"},{"location":"api/oracles/dirac/#integration-with-mis-algorithm","title":"Integration with MIS Algorithm","text":""},{"location":"api/oracles/dirac/#oracle-call-pattern","title":"Oracle Call Pattern","text":"<pre><code>from motzkinstraus.algorithms import find_mis_with_oracle\n\n# Dirac oracle integrates seamlessly with MIS algorithm\nG = nx.barabasi_albert_graph(100, 5)\noracle = DiracOracle(num_samples=30, relax_schedule=3)\n\nmis_set, oracle_calls = find_mis_with_oracle(G, oracle)\nprint(f\"MIS size: {len(mis_set)}\")\nprint(f\"Oracle calls made: {oracle_calls}\")\nprint(f\"Total quantum measurements: {oracle_calls * oracle.num_samples}\")\n</code></pre>"},{"location":"api/oracles/dirac/#quantum-specific-optimizations","title":"Quantum-Specific Optimizations","text":"<pre><code>class QuantumAwareMISAlgorithm:\n    def __init__(self, oracle: DiracOracle):\n        self.oracle = oracle\n        self.quantum_cache = {}  # Cache quantum solutions\n\n    def find_mis(self, graph):\n        # Pre-warm quantum system with small problems\n        self._quantum_warmup()\n\n        # Use quantum-specific heuristics\n        return self._quantum_mis_search(graph)\n\n    def _quantum_warmup(self):\n        \"\"\"Pre-solve small problems to stabilize quantum system.\"\"\"\n        warmup_graph = nx.cycle_graph(4)\n        self.oracle.get_omega(warmup_graph)\n</code></pre> <p>Related Documentation: - QP Solvers Overview - Compare with other solvers - Hybrid Oracles - Combining quantum with classical methods - Performance Tuning - Optimization strategies</p>"},{"location":"api/oracles/hybrid/","title":"Hybrid Oracles","text":"<p>Hybrid oracles combine multiple solving approaches to achieve optimal performance across different problem types and sizes. They intelligently select or blend classical and quantum methods based on problem characteristics, providing the best of both worlds.</p>"},{"location":"api/oracles/hybrid/#design-philosophy","title":"Design Philosophy","text":""},{"location":"api/oracles/hybrid/#adaptive-strategy-selection","title":"Adaptive Strategy Selection","text":"<p>Hybrid oracles implement adaptive algorithms that:</p> <ol> <li>Analyze problem characteristics: Size, density, structure</li> <li>Select optimal method: Based on empirical performance data</li> <li>Fall back gracefully: When primary method fails</li> <li>Learn from experience: Improve selection over time</li> </ol>"},{"location":"api/oracles/hybrid/#performance-optimization-goals","title":"Performance Optimization Goals","text":"<ul> <li>Accuracy: Maintain high solution quality across problem types</li> <li>Speed: Minimize total computation time</li> <li>Robustness: Handle edge cases and solver failures</li> <li>Scalability: Efficient performance from small to large problems</li> </ul>"},{"location":"api/oracles/hybrid/#diracnetworkxhybridoracle","title":"DiracNetworkXHybridOracle","text":""},{"location":"api/oracles/hybrid/#overview","title":"Overview","text":"<p>The <code>DiracNetworkXHybridOracle</code> combines exact NetworkX algorithms for small graphs with Dirac-3 quantum annealing for larger problems.</p>"},{"location":"api/oracles/hybrid/#decision-strategy","title":"Decision Strategy","text":"<pre><code>def select_method(graph):\n    \"\"\"Select solving method based on graph size.\"\"\"\n    n = graph.number_of_nodes()\n\n    if n &lt;= threshold:\n        return \"networkx_exact\"    # Use exact algorithms\n    else:\n        return \"dirac_quantum\"     # Use quantum annealing\n</code></pre>"},{"location":"api/oracles/hybrid/#api-reference","title":"API Reference","text":"<pre><code>DiracNetworkXHybridOracle(\n    networkx_size_threshold: int = 15,\n    num_samples: int = 100,\n    relax_schedule: int = 2,\n    solution_precision: float = 0.001,\n    sum_constraint: int = 1,\n    mean_photon_number: Optional[float] = None,\n    quantum_fluctuation_coefficient: Optional[int] = None\n)\n</code></pre>"},{"location":"api/oracles/hybrid/#parameters","title":"Parameters","text":"networkx_size_threshold: int = 15 Maximum graph size for using exact NetworkX algorithms. Typical range: 10-25 Rationale: Exact algorithms become prohibitively slow beyond this threshold.  num_samples: int = 100 Number of samples for Dirac-3 quantum solver (when used).  relax_schedule: int = 2 Relaxation schedule for quantum annealing (when used).  <p>Additional parameters follow Dirac-3 Oracle specification.</p>"},{"location":"api/oracles/hybrid/#usage-examples","title":"Usage Examples","text":""},{"location":"api/oracles/hybrid/#basic-hybrid-usage","title":"Basic Hybrid Usage","text":"<pre><code>from motzkinstraus.oracles.dirac_hybrid import DiracNetworkXHybridOracle\n\n# Hybrid oracle with default threshold\nhybrid_oracle = DiracNetworkXHybridOracle()\n\n# Small graph - uses exact NetworkX\nsmall_G = nx.cycle_graph(12)\nomega_small = hybrid_oracle.get_omega(small_G)\nprint(f\"Method used: {hybrid_oracle.last_method_used}\")  # \"networkx\"\n\n# Large graph - uses Dirac-3\nlarge_G = nx.barabasi_albert_graph(50, 4)\nomega_large = hybrid_oracle.get_omega(large_G)\nprint(f\"Method used: {hybrid_oracle.last_method_used}\")  # \"dirac\"\n</code></pre>"},{"location":"api/oracles/hybrid/#custom-threshold-configuration","title":"Custom Threshold Configuration","text":"<pre><code># Conservative threshold for guaranteed exact solutions\nconservative_oracle = DiracNetworkXHybridOracle(\n    networkx_size_threshold=20,    # Larger exact region\n    num_samples=50,                # Fewer quantum samples (faster)\n    relax_schedule=1               # Fastest quantum schedule\n)\n\n# Aggressive threshold for speed\naggressive_oracle = DiracNetworkXHybridOracle(\n    networkx_size_threshold=8,     # Smaller exact region\n    num_samples=150,               # More quantum samples (quality)\n    relax_schedule=4               # Best quantum schedule\n)\n</code></pre>"},{"location":"api/oracles/hybrid/#performance-characteristics","title":"Performance Characteristics","text":"<pre><code># Performance analysis by graph size\ndef analyze_hybrid_performance():\n    oracle = DiracNetworkXHybridOracle(networkx_size_threshold=15)\n\n    sizes = [5, 10, 15, 20, 30, 50, 100]\n    results = []\n\n    for n in sizes:\n        G = nx.erdos_renyi_graph(n, 0.3)\n        start_time = time.time()\n        omega = oracle.get_omega(G)\n        elapsed = time.time() - start_time\n\n        results.append({\n            'size': n,\n            'method': oracle.last_method_used,\n            'time': elapsed,\n            'omega': omega\n        })\n\n    return results\n</code></pre>"},{"location":"api/oracles/hybrid/#diracpgdhybridoracle","title":"DiracPGDHybridOracle","text":""},{"location":"api/oracles/hybrid/#overview_1","title":"Overview","text":"<p>The <code>DiracPGDHybridOracle</code> combines JAX Projected Gradient Descent with Dirac-3 quantum annealing in a sequential or parallel fashion.</p>"},{"location":"api/oracles/hybrid/#strategy-options","title":"Strategy Options","text":"<ol> <li>PGD First: Try fast classical optimization, fall back to quantum</li> <li>Quantum First: Use quantum as primary, PGD for refinement</li> <li>Parallel: Run both methods, select best result</li> <li>Sequential: Use PGD result to initialize quantum solver</li> </ol>"},{"location":"api/oracles/hybrid/#api-reference_1","title":"API Reference","text":"<pre><code>DiracPGDHybridOracle(\n    use_pgd_first: bool = True,\n    pgd_time_limit: float = 10.0,\n    parallel_execution: bool = False,\n    # PGD parameters (prefixed with pgd_)\n    pgd_learning_rate: float = 0.02,\n    pgd_max_iterations: int = 1000,\n    pgd_num_restarts: int = 5,\n    pgd_tolerance: float = 1e-6,\n    # Dirac parameters (prefixed with dirac_)\n    dirac_num_samples: int = 50,\n    dirac_relax_schedule: int = 2,\n    dirac_sum_constraint: int = 1,\n    dirac_mean_photon_number: Optional[float] = None,\n    dirac_quantum_fluctuation_coefficient: Optional[int] = None\n)\n</code></pre>"},{"location":"api/oracles/hybrid/#key-parameters","title":"Key Parameters","text":"use_pgd_first: bool = True Whether to try PGD optimization before quantum annealing.  pgd_time_limit: float = 10.0 Maximum time (seconds) to spend on PGD optimization.  parallel_execution: bool = False Whether to run PGD and Dirac-3 in parallel and select best result."},{"location":"api/oracles/hybrid/#usage-examples_1","title":"Usage Examples","text":""},{"location":"api/oracles/hybrid/#sequential-strategy-default","title":"Sequential Strategy (Default)","text":"<pre><code>from motzkinstraus.oracles.dirac_pgd_hybrid import DiracPGDHybridOracle\n\n# PGD first, quantum fallback\nhybrid_oracle = DiracPGDHybridOracle(\n    use_pgd_first=True,\n    pgd_time_limit=15.0,           # Give PGD 15 seconds\n    pgd_num_restarts=10,           # Thorough PGD search\n    dirac_num_samples=30           # Moderate quantum effort\n)\n\nG = nx.karate_club_graph()\nomega = hybrid_oracle.get_omega(G)\nprint(f\"Methods used: {hybrid_oracle.methods_attempted}\")\nprint(f\"Best method: {hybrid_oracle.best_method}\")\n</code></pre>"},{"location":"api/oracles/hybrid/#parallel-strategy","title":"Parallel Strategy","text":"<pre><code># Run both methods simultaneously\nparallel_oracle = DiracPGDHybridOracle(\n    parallel_execution=True,\n    pgd_num_restarts=5,            # Balanced PGD effort\n    dirac_num_samples=40,          # Balanced quantum effort\n    dirac_relax_schedule=3         # High-quality quantum\n)\n\n# Both methods run concurrently\nomega = parallel_oracle.get_omega(G)\nprint(f\"PGD result: {parallel_oracle.pgd_result}\")\nprint(f\"Dirac result: {parallel_oracle.dirac_result}\")\nprint(f\"Selected: {parallel_oracle.selected_result}\")\n</code></pre>"},{"location":"api/oracles/hybrid/#quantum-first-strategy","title":"Quantum-First Strategy","text":"<pre><code># Quantum primary, PGD refinement\nquantum_first_oracle = DiracPGDHybridOracle(\n    use_pgd_first=False,           # Quantum first\n    dirac_num_samples=100,         # High quantum effort\n    dirac_relax_schedule=4,        # Best quantum quality\n    pgd_learning_rate=0.001,       # Fine-tuned refinement\n    pgd_max_iterations=500         # Limited refinement\n)\n</code></pre>"},{"location":"api/oracles/hybrid/#advanced-configurations","title":"Advanced Configurations","text":""},{"location":"api/oracles/hybrid/#problem-adaptive-hybrid","title":"Problem-Adaptive Hybrid","text":"<pre><code>class AdaptiveHybridOracle(DiracPGDHybridOracle):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.performance_history = {}\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        # Analyze problem characteristics\n        n = adjacency_matrix.shape[0]\n        density = np.sum(adjacency_matrix) / (n * (n - 1))\n        problem_key = (n // 10, int(density * 10))  # Discretize characteristics\n\n        # Adapt strategy based on historical performance\n        if problem_key in self.performance_history:\n            history = self.performance_history[problem_key]\n            if history['pgd_success_rate'] &gt; 0.8:\n                self.pgd_time_limit *= 1.5  # Give PGD more time\n            else:\n                self.dirac_num_samples = min(150, self.dirac_num_samples * 1.2)\n\n        # Execute hybrid strategy\n        result = super().solve_quadratic_program(adjacency_matrix)\n\n        # Update performance history\n        self._update_history(problem_key, result)\n\n        return result\n</code></pre>"},{"location":"api/oracles/hybrid/#multi-stage-hybrid","title":"Multi-Stage Hybrid","text":"<pre><code>class MultiStageHybridOracle(Oracle):\n    def __init__(self):\n        super().__init__()\n        self.fast_oracle = ProjectedGradientDescentOracle(\n            num_restarts=3, max_iterations=200\n        )\n        self.quality_oracle = DiracOracle(\n            num_samples=50, relax_schedule=3\n        )\n        self.exact_oracle = GurobiOracle()\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        n = adjacency_matrix.shape[0]\n\n        # Stage 1: Fast approximation\n        fast_result = self.fast_oracle.solve_quadratic_program(adjacency_matrix)\n\n        # Stage 2: Quality check\n        if n &lt; 30:  # Small enough for exact solution\n            exact_result = self.exact_oracle.solve_quadratic_program(adjacency_matrix)\n            if abs(fast_result - exact_result) &lt; 1e-6:\n                return exact_result  # Fast result was optimal\n\n        # Stage 3: High-quality approximation\n        return self.quality_oracle.solve_quadratic_program(adjacency_matrix)\n</code></pre>"},{"location":"api/oracles/hybrid/#custom-hybrid-patterns","title":"Custom Hybrid Patterns","text":""},{"location":"api/oracles/hybrid/#ensemble-hybrid-oracle","title":"Ensemble Hybrid Oracle","text":"<pre><code>class EnsembleHybridOracle(Oracle):\n    \"\"\"Weighted ensemble of multiple oracles.\"\"\"\n\n    def __init__(self, oracles, weights=None):\n        super().__init__()\n        self.oracles = oracles\n        self.weights = weights or [1.0] * len(oracles)\n        self.normalize_weights()\n\n    def normalize_weights(self):\n        total = sum(self.weights)\n        self.weights = [w / total for w in self.weights]\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        results = []\n        for oracle in self.oracles:\n            try:\n                result = oracle.solve_quadratic_program(adjacency_matrix)\n                results.append(result)\n            except OracleError:\n                results.append(0.0)  # Fallback value\n\n        # Weighted average\n        return sum(w * r for w, r in zip(self.weights, results))\n\n# Usage\nensemble = EnsembleHybridOracle(\n    oracles=[\n        ProjectedGradientDescentOracle(num_restarts=10),\n        MirrorDescentOracle(num_restarts=10),\n        DiracOracle(num_samples=30)\n    ],\n    weights=[0.4, 0.3, 0.3]  # Favor classical methods slightly\n)\n</code></pre>"},{"location":"api/oracles/hybrid/#confidence-based-hybrid","title":"Confidence-Based Hybrid","text":"<pre><code>class ConfidenceHybridOracle(Oracle):\n    \"\"\"Select oracle based on confidence in solution.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.oracles = [\n            ProjectedGradientDescentOracle(num_restarts=5),\n            DiracOracle(num_samples=30)\n        ]\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        results = []\n        confidences = []\n\n        for oracle in self.oracles:\n            result = oracle.solve_quadratic_program(adjacency_matrix)\n            confidence = self.estimate_confidence(oracle, adjacency_matrix, result)\n            results.append(result)\n            confidences.append(confidence)\n\n        # Select result with highest confidence\n        best_idx = np.argmax(confidences)\n        return results[best_idx]\n\n    def estimate_confidence(self, oracle, adjacency_matrix, result):\n        \"\"\"Estimate confidence in oracle result.\"\"\"\n        if hasattr(oracle, 'convergence_history'):\n            # Check convergence stability\n            history = oracle.convergence_history\n            if len(history) &gt; 10:\n                recent_variance = np.var(history[-10:])\n                return 1.0 / (1.0 + recent_variance)\n\n        # Default confidence based on oracle type\n        if isinstance(oracle, GurobiOracle):\n            return 1.0  # Exact solver\n        elif isinstance(oracle, DiracOracle):\n            return 0.8  # High-quality quantum\n        else:\n            return 0.6  # Classical approximation\n</code></pre>"},{"location":"api/oracles/hybrid/#hybrid-performance-analysis","title":"Hybrid Performance Analysis","text":""},{"location":"api/oracles/hybrid/#benchmarking-framework","title":"Benchmarking Framework","text":"<pre><code>def benchmark_hybrid_oracles():\n    \"\"\"Compare different hybrid strategies.\"\"\"\n\n    oracles = {\n        'NetworkX-Dirac': DiracNetworkXHybridOracle(networkx_size_threshold=15),\n        'PGD-Dirac Sequential': DiracPGDHybridOracle(use_pgd_first=True),\n        'PGD-Dirac Parallel': DiracPGDHybridOracle(parallel_execution=True),\n        'Pure PGD': ProjectedGradientDescentOracle(num_restarts=10),\n        'Pure Dirac': DiracOracle(num_samples=50)\n    }\n\n    # Test graphs of various sizes and types\n    test_graphs = [\n        (nx.cycle_graph(10), \"cycle_10\"),\n        (nx.erdos_renyi_graph(25, 0.3), \"er_25_sparse\"),\n        (nx.erdos_renyi_graph(25, 0.7), \"er_25_dense\"),\n        (nx.barabasi_albert_graph(50, 3), \"ba_50_3\"),\n        (nx.karate_club_graph(), \"karate\")\n    ]\n\n    results = {}\n    for oracle_name, oracle in oracles.items():\n        results[oracle_name] = {}\n        for graph, graph_name in test_graphs:\n            start_time = time.time()\n            omega = oracle.get_omega(graph)\n            elapsed = time.time() - start_time\n\n            results[oracle_name][graph_name] = {\n                'omega': omega,\n                'time': elapsed,\n                'calls': oracle.call_count\n            }\n\n    return results\n</code></pre>"},{"location":"api/oracles/hybrid/#performance-visualization","title":"Performance Visualization","text":"<pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef plot_hybrid_performance(results):\n    \"\"\"Visualize hybrid oracle performance.\"\"\"\n\n    fig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n    # Time performance\n    times = {oracle: [data['time'] for data in results[oracle].values()] \n             for oracle in results}\n    axes[0,0].boxplot(times.values(), labels=times.keys())\n    axes[0,0].set_title('Execution Time Distribution')\n    axes[0,0].set_ylabel('Time (seconds)')\n\n    # Solution quality (assuming we know optimal values)\n    # ... additional plotting code\n\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"api/oracles/hybrid/#best-practices","title":"Best Practices","text":""},{"location":"api/oracles/hybrid/#hybrid-oracle-selection","title":"Hybrid Oracle Selection","text":"<pre><code>def recommend_hybrid_oracle(graph_characteristics):\n    \"\"\"Recommend optimal hybrid oracle based on problem.\"\"\"\n\n    n = graph_characteristics['nodes']\n    density = graph_characteristics['density']\n    structure = graph_characteristics['structure']  # 'regular', 'random', 'scale-free'\n\n    if n &lt;= 20:\n        return DiracNetworkXHybridOracle(networkx_size_threshold=25)\n    elif density &gt; 0.7:  # Dense graphs\n        return DiracPGDHybridOracle(\n            use_pgd_first=False,  # Quantum handles density well\n            dirac_relax_schedule=4\n        )\n    elif structure == 'scale-free':  # Complex structure\n        return DiracPGDHybridOracle(\n            parallel_execution=True,  # Try both approaches\n            pgd_num_restarts=15\n        )\n    else:  # General case\n        return DiracPGDHybridOracle(use_pgd_first=True)\n</code></pre>"},{"location":"api/oracles/hybrid/#configuration-guidelines","title":"Configuration Guidelines","text":"<ol> <li>Small graphs (&lt; 20 nodes): Use NetworkX-Dirac hybrid with threshold 20-25</li> <li>Medium graphs (20-100 nodes): Use PGD-Dirac sequential hybrid</li> <li>Large graphs (&gt; 100 nodes): Consider parallel execution for time-critical applications</li> <li>Dense graphs: Favor quantum-first strategies</li> <li>Sparse graphs: Favor classical-first strategies</li> </ol>"},{"location":"api/oracles/hybrid/#error-handling-in-hybrids","title":"Error Handling in Hybrids","text":"<pre><code>class RobustHybridOracle(DiracPGDHybridOracle):\n    def solve_quadratic_program(self, adjacency_matrix):\n        try:\n            return super().solve_quadratic_program(adjacency_matrix)\n        except Exception as e:\n            # Fallback to most reliable method\n            fallback_oracle = ProjectedGradientDescentOracle(num_restarts=20)\n            return fallback_oracle.solve_quadratic_program(adjacency_matrix)\n</code></pre> <p>Related Documentation: - Oracle Overview - Base oracle concepts - JAX Solvers - Classical optimization methods - Dirac Oracle - Quantum computing approach - Performance Tuning - Optimization strategies</p>"},{"location":"api/oracles/jax-solvers/","title":"JAX-Based Oracles","text":"<p>The JAX oracle family provides high-performance gradient-based optimization for the Motzkin-Straus quadratic program. These oracles leverage JAX's just-in-time (JIT) compilation and automatic differentiation to achieve excellent performance on modern hardware.</p>"},{"location":"api/oracles/jax-solvers/#jax-framework-overview","title":"JAX Framework Overview","text":""},{"location":"api/oracles/jax-solvers/#key-advantages","title":"Key Advantages","text":"<ul> <li>JIT Compilation: Automatic compilation to optimized XLA code</li> <li>Automatic Differentiation: Exact gradients without manual derivation</li> <li>Vectorization: Efficient parallel operations on modern hardware</li> <li>GPU/TPU Support: Seamless acceleration on specialized hardware</li> </ul>"},{"location":"api/oracles/jax-solvers/#architectural-design","title":"Architectural Design","text":"<pre><code># Common JAX oracle pattern\n@jit\ndef optimization_step(x, adjacency_matrix, learning_rate):\n    \"\"\"JIT-compiled optimization step.\"\"\"\n    energy = 0.5 * x.T @ adjacency_matrix @ x\n    gradient = adjacency_matrix @ x\n    return update_rule(x, gradient, learning_rate)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#projectedgradientdescentoracle","title":"ProjectedGradientDescentOracle","text":""},{"location":"api/oracles/jax-solvers/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>Projected Gradient Descent (PGD) solves the constrained optimization problem:</p> \\[\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x\\] <p>through the iterative updates:</p> <ol> <li>Gradient step: \\(y^{(k+1)} = x^{(k)} + \\alpha \\nabla f(x^{(k)})\\)</li> <li>Simplex projection: \\(x^{(k+1)} = \\Pi_{\\Delta_n}(y^{(k+1)})\\)</li> </ol> <p>where \\(\\Pi_{\\Delta_n}\\) is the projection onto the probability simplex.</p>"},{"location":"api/oracles/jax-solvers/#simplex-projection-algorithm","title":"Simplex Projection Algorithm","text":"<p>The projection \\(\\Pi_{\\Delta_n}(y)\\) finds the closest point in \\(\\Delta_n\\) to \\(y\\):</p> <pre><code>def project_simplex(y):\n    \"\"\"Project vector y onto probability simplex.\"\"\"\n    n = len(y)\n    sorted_y = jnp.sort(y)[::-1]  # Descending order\n\n    # Find the threshold for projection\n    cumsum = jnp.cumsum(sorted_y)\n    k = jnp.arange(1, n + 1)\n    threshold_conditions = sorted_y - (cumsum - 1) / k &gt; 0\n    k_max = jnp.sum(threshold_conditions)\n    theta = (jnp.sum(sorted_y[:k_max]) - 1) / k_max\n\n    return jnp.maximum(y - theta, 0)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#api-reference","title":"API Reference","text":"<pre><code>ProjectedGradientDescentOracle(\n    learning_rate: float = 0.01,\n    max_iterations: int = 2000,\n    tolerance: float = 1e-6,\n    min_iterations: int = 50,\n    num_restarts: int = 10,\n    dirichlet_alpha: float = 1.0,\n    verbose: bool = False\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#parameters","title":"Parameters","text":"learning_rate: float = 0.01 Step size for gradient ascent. Higher values converge faster but may overshoot. Typical range: 0.001-0.1 max_iterations: int = 2000 Maximum number of optimization iterations per restart.  tolerance: float = 1e-6 Convergence tolerance for early stopping based on energy change.  min_iterations: int = 50 Minimum iterations before early stopping can occur.  num_restarts: int = 10 Number of random initializations. More restarts improve solution quality.  dirichlet_alpha: float = 1.0 Concentration parameter for Dirichlet initialization. Lower values create more concentrated starting points."},{"location":"api/oracles/jax-solvers/#usage-examples","title":"Usage Examples","text":""},{"location":"api/oracles/jax-solvers/#basic-usage","title":"Basic Usage","text":"<pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nimport networkx as nx\n\nG = nx.karate_club_graph()\noracle = ProjectedGradientDescentOracle()\nomega = oracle.get_omega(G)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#high-quality-configuration","title":"High-Quality Configuration","text":"<pre><code># Configuration for best solution quality\noracle = ProjectedGradientDescentOracle(\n    learning_rate=0.02,      # Moderate step size\n    max_iterations=5000,     # More iterations\n    num_restarts=20,         # Many restarts\n    tolerance=1e-8,          # Tight convergence\n    dirichlet_alpha=0.5      # Concentrated initialization\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#fast-configuration","title":"Fast Configuration","text":"<pre><code># Configuration for speed over quality\noracle = ProjectedGradientDescentOracle(\n    learning_rate=0.05,      # Larger steps\n    max_iterations=500,      # Fewer iterations\n    num_restarts=3,          # Fewer restarts\n    tolerance=1e-5           # Looser convergence\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#mirrordescentoracle","title":"MirrorDescentOracle","text":""},{"location":"api/oracles/jax-solvers/#mathematical-foundation_1","title":"Mathematical Foundation","text":"<p>Mirror Descent uses the exponentiated gradient method, which is naturally suited for simplex constraints. The update rule works in the \"dual space\":</p> <ol> <li>Dual update: \\(\\theta^{(k+1)} = \\theta^{(k)} + \\alpha \\nabla f(x^{(k)})\\)</li> <li>Primal mapping: \\(x^{(k+1)} = \\frac{\\exp(\\theta^{(k+1)})}{\\sum_i \\exp(\\theta^{(k+1)}_i)}\\)</li> </ol> <p>This naturally maintains the simplex constraint \\(\\sum_i x_i = 1, x_i \\geq 0\\) without explicit projection.</p>"},{"location":"api/oracles/jax-solvers/#entropic-regularization","title":"Entropic Regularization","text":"<p>The method can be viewed as solving the regularized problem:</p> \\[\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x + \\frac{1}{\\beta} H(x)\\] <p>where \\(H(x) = -\\sum_i x_i \\log x_i\\) is the entropy regularizer and \\(\\beta\\) is the inverse temperature.</p>"},{"location":"api/oracles/jax-solvers/#api-reference_1","title":"API Reference","text":"<pre><code>MirrorDescentOracle(\n    learning_rate: float = 0.005,\n    max_iterations: int = 2000,\n    tolerance: float = 1e-6,\n    min_iterations: int = 50,\n    num_restarts: int = 10,\n    dirichlet_alpha: float = 1.0,\n    verbose: bool = False\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#key-differences-from-pgd","title":"Key Differences from PGD","text":"<ul> <li>Learning rate: Typically needs smaller values (default 0.005 vs 0.01)</li> <li>No projection: Updates naturally stay on simplex</li> <li>Entropy bias: Tends toward uniform distributions</li> <li>Numerical stability: Better handling of boundary conditions</li> </ul>"},{"location":"api/oracles/jax-solvers/#usage-examples_1","title":"Usage Examples","text":""},{"location":"api/oracles/jax-solvers/#comparison-with-pgd","title":"Comparison with PGD","text":"<pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.oracles.jax_mirror import MirrorDescentOracle\n\n# Same graph, different methods\nG = nx.erdos_renyi_graph(50, 0.3)\n\npgd_oracle = ProjectedGradientDescentOracle(num_restarts=5)\nmirror_oracle = MirrorDescentOracle(num_restarts=5)\n\nomega_pgd = pgd_oracle.get_omega(G)\nomega_mirror = mirror_oracle.get_omega(G)\n\nprint(f\"PGD result: {omega_pgd}\")\nprint(f\"Mirror Descent result: {omega_mirror}\")\n</code></pre>"},{"location":"api/oracles/jax-solvers/#dense-graph-optimization","title":"Dense Graph Optimization","text":"<pre><code># Mirror Descent often works better on dense graphs\ndense_G = nx.erdos_renyi_graph(30, 0.8)  # 80% edge probability\n\noracle = MirrorDescentOracle(\n    learning_rate=0.008,     # Slightly higher for dense graphs\n    num_restarts=15,         # More restarts for difficult problems\n    max_iterations=3000      # More iterations for convergence\n)\n\nomega = oracle.get_omega(dense_G)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#frankwolfeoracle","title":"FrankWolfeOracle","text":""},{"location":"api/oracles/jax-solvers/#mathematical-foundation_2","title":"Mathematical Foundation","text":"<p>The Frank-Wolfe algorithm (also called conditional gradient) avoids explicit projection by solving linear optimization subproblems:</p> <ol> <li>Linear oracle: \\(s^{(k)} = \\arg\\max_{s \\in \\Delta_n} \\langle \\nabla f(x^{(k)}), s \\rangle\\)</li> <li>Line search: \\(\\gamma^{(k)} = \\arg\\max_{\\gamma \\in [0,1]} f((1-\\gamma)x^{(k)} + \\gamma s^{(k)})\\)</li> <li>Update: \\(x^{(k+1)} = (1-\\gamma^{(k)})x^{(k)} + \\gamma^{(k)} s^{(k)}\\)</li> </ol>"},{"location":"api/oracles/jax-solvers/#linear-subproblem-solution","title":"Linear Subproblem Solution","text":"<p>For the simplex constraint, the linear subproblem has a simple solution:</p> \\[s^{(k)} = e_j \\text{ where } j = \\arg\\max_i (\\nabla f(x^{(k)}))_i\\] <p>This makes each iteration very efficient.</p>"},{"location":"api/oracles/jax-solvers/#key-properties","title":"Key Properties","text":"<ul> <li>Projection-free: No explicit simplex projection needed</li> <li>Sparse iterates: Solutions tend to be sparse</li> <li>Memory efficient: Constant memory requirements</li> <li>Convergence rate: O(1/k) for smooth objectives</li> </ul>"},{"location":"api/oracles/jax-solvers/#usage-examples_2","title":"Usage Examples","text":""},{"location":"api/oracles/jax-solvers/#large-scale-problems","title":"Large-Scale Problems","text":"<pre><code>from motzkinstraus.oracles.jax_frank_wolfe import FrankWolfeOracle\n\n# Frank-Wolfe excels on large, sparse problems\nlarge_sparse_G = nx.barabasi_albert_graph(500, 3)\n\noracle = FrankWolfeOracle(\n    max_iterations=1000,     # Fewer iterations due to efficiency\n    line_search_steps=20,    # Accurate line search\n    verbose=True             # Monitor progress\n)\n\nomega = oracle.get_omega(large_sparse_G)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#performance-comparison","title":"Performance Comparison","text":""},{"location":"api/oracles/jax-solvers/#computational-complexity","title":"Computational Complexity","text":"Oracle Per-Iteration Cost Memory Usage Convergence Rate PGD O(n\u00b2 + projection) O(n\u00b2) O(1/\u221ak) Mirror Descent O(n\u00b2) O(n\u00b2) O(log k/k) Frank-Wolfe O(n\u00b2) O(n) O(1/k)"},{"location":"api/oracles/jax-solvers/#problem-specific-recommendations","title":"Problem-Specific Recommendations","text":""},{"location":"api/oracles/jax-solvers/#graph-density","title":"Graph Density","text":"<pre><code>def select_jax_oracle(graph):\n    \"\"\"Select JAX oracle based on graph properties.\"\"\"\n    n = graph.number_of_nodes()\n    m = graph.number_of_edges()\n    density = 2 * m / (n * (n - 1)) if n &gt; 1 else 0\n\n    if density &gt; 0.7:\n        return MirrorDescentOracle()  # Better for dense graphs\n    elif n &gt; 200:\n        return FrankWolfeOracle()     # Memory efficient for large graphs\n    else:\n        return ProjectedGradientDescentOracle()  # General purpose\n</code></pre>"},{"location":"api/oracles/jax-solvers/#quality-vs-speed","title":"Quality vs Speed","text":"<pre><code># Quality-focused configuration\nquality_config = {\n    'num_restarts': 20,\n    'max_iterations': 5000,\n    'tolerance': 1e-8,\n    'learning_rate': 0.01\n}\n\n# Speed-focused configuration  \nspeed_config = {\n    'num_restarts': 3,\n    'max_iterations': 500,\n    'tolerance': 1e-5,\n    'learning_rate': 0.05\n}\n</code></pre>"},{"location":"api/oracles/jax-solvers/#advanced-features","title":"Advanced Features","text":""},{"location":"api/oracles/jax-solvers/#multi-restart-strategy","title":"Multi-restart Strategy","text":"<p>All JAX oracles implement sophisticated multi-restart strategies:</p> <pre><code>def multi_restart_optimization(adjacency_matrix, num_restarts, oracle_config):\n    \"\"\"Multi-restart optimization with Dirichlet initialization.\"\"\"\n    best_energy = -float('inf')\n    best_solution = None\n\n    for restart in range(num_restarts):\n        # Dirichlet initialization\n        alpha = oracle_config.dirichlet_alpha\n        x_init = np.random.dirichlet([alpha] * n)\n\n        # Run optimization\n        x_final, energy = single_restart_optimize(adjacency_matrix, x_init)\n\n        if energy &gt; best_energy:\n            best_energy = energy\n            best_solution = x_final\n\n    return best_solution, best_energy\n</code></pre>"},{"location":"api/oracles/jax-solvers/#convergence-monitoring","title":"Convergence Monitoring","text":"<pre><code># Enable detailed monitoring\noracle = ProjectedGradientDescentOracle(verbose=True)\nomega = oracle.get_omega(G)\n\n# Access convergence information\nprint(f\"Converged in {oracle.last_iterations} iterations\")\nprint(f\"Final energy: {oracle.last_energy:.8f}\")\nprint(f\"Energy history: {oracle.convergence_history}\")\n\n# Plot convergence\nimport matplotlib.pyplot as plt\nplt.plot(oracle.convergence_history)\nplt.xlabel('Iteration')\nplt.ylabel('Objective Value')\nplt.title('Convergence History')\n</code></pre>"},{"location":"api/oracles/jax-solvers/#hardware-acceleration","title":"Hardware Acceleration","text":"<pre><code># Verify GPU availability\nimport jax\nprint(f\"JAX backend: {jax.default_backend()}\")\nprint(f\"Available devices: {jax.devices()}\")\n\n# JAX oracles automatically use available accelerators\noracle = ProjectedGradientDescentOracle()  # Will use GPU if available\n</code></pre>"},{"location":"api/oracles/jax-solvers/#custom-initialization-strategies","title":"Custom Initialization Strategies","text":"<pre><code>class CustomInitPGDOracle(ProjectedGradientDescentOracle):\n    def __init__(self, init_strategy='dirichlet', **kwargs):\n        super().__init__(**kwargs)\n        self.init_strategy = init_strategy\n\n    def get_initialization(self, n):\n        if self.init_strategy == 'uniform':\n            return np.ones(n) / n\n        elif self.init_strategy == 'random_vertex':\n            x = np.zeros(n)\n            x[np.random.randint(n)] = 1.0\n            return x\n        elif self.init_strategy == 'degree_weighted':\n            # Initialize based on node degrees (requires graph)\n            degrees = np.array([self.current_graph.degree(i) for i in range(n)])\n            return degrees / np.sum(degrees)\n        else:  # dirichlet\n            return np.random.dirichlet([self.dirichlet_alpha] * n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#troubleshooting","title":"Troubleshooting","text":""},{"location":"api/oracles/jax-solvers/#common-issues","title":"Common Issues","text":""},{"location":"api/oracles/jax-solvers/#convergence-problems","title":"Convergence Problems","text":"<pre><code># If optimization fails to converge\noracle = ProjectedGradientDescentOracle(\n    learning_rate=0.005,     # Reduce learning rate\n    max_iterations=10000,    # Increase iterations\n    num_restarts=30,         # More restarts\n    tolerance=1e-7           # Tighter tolerance\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#numerical-instability","title":"Numerical Instability","text":"<pre><code># For numerically challenging problems\noracle = MirrorDescentOracle(\n    learning_rate=0.001,     # Very small steps\n    min_iterations=100,      # Ensure minimum progress\n    verbose=True             # Monitor for issues\n)\n</code></pre>"},{"location":"api/oracles/jax-solvers/#memory-issues","title":"Memory Issues","text":"<pre><code># For large problems with memory constraints\noracle = FrankWolfeOracle(\n    max_iterations=500,      # Fewer iterations\n    line_search_steps=5      # Simpler line search\n)\n</code></pre> <p>Next Steps: - Gurobi Oracle - Commercial solver integration - Hybrid Oracles - Combining JAX with other methods - Performance Tuning - Optimization strategies</p>"},{"location":"api/oracles/overview/","title":"Oracle API Overview","text":"<p>Oracles are the computational engines that solve the Motzkin-Straus quadratic programming problem. Each oracle implements the abstract <code>Oracle</code> base class and provides a specialized approach to finding the optimal value of:</p> \\[\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x\\]"},{"location":"api/oracles/overview/#oracle-architecture","title":"Oracle Architecture","text":""},{"location":"api/oracles/overview/#base-oracle-class","title":"Base Oracle Class","text":"<p>All oracles inherit from the abstract <code>Oracle</code> base class:</p> <pre><code>from abc import ABC, abstractmethod\nimport networkx as nx\n\nclass Oracle(ABC):\n    @abstractmethod\n    def solve_quadratic_program(self, adjacency_matrix: np.ndarray) -&gt; float:\n        \"\"\"Solve the Motzkin-Straus QP and return optimal value.\"\"\"\n        pass\n\n    def get_omega(self, graph: nx.Graph) -&gt; int:\n        \"\"\"Convert QP solution to clique number using M-S formula.\"\"\"\n        # Implementation handles floating-point robustness\n        pass\n</code></pre>"},{"location":"api/oracles/overview/#key-design-principles","title":"Key Design Principles","text":"<ol> <li>Separation of Concerns: QP solving vs. discrete conversion</li> <li>Robustness: Handle floating-point precision issues</li> <li>Monitoring: Track oracle calls and convergence</li> <li>Flexibility: Support various solver backends</li> </ol>"},{"location":"api/oracles/overview/#oracle-types","title":"Oracle Types","text":""},{"location":"api/oracles/overview/#classical-optimization","title":"Classical Optimization","text":"#### Gradient-Based Oracles - **JAX PGD**: Projected gradient descent with simplex projection - **JAX Mirror Descent**: Exponentiated gradient updates  - **JAX Frank-Wolfe**: Projection-free conditional gradient method  **Strengths**: Fast, predictable, well-understood convergence   **Limitations**: May get trapped in local minima     #### Commercial Solvers - **Gurobi**: Professional-grade non-convex QP solver  **Strengths**: Global optimality guarantees, robust implementation   **Limitations**: Requires license, can be slow on large problems"},{"location":"api/oracles/overview/#quantum-computing","title":"Quantum Computing","text":"#### Quantum Annealing - **Dirac-3**: Photonic quantum computing with time-bin encoding  **Strengths**: Natural global optimization, handles large problems   **Limitations**: Quantum hardware access required, approximate solutions"},{"location":"api/oracles/overview/#hybrid-approaches","title":"Hybrid Approaches","text":"#### Adaptive Oracles - **DiracNetworkXHybrid**: Exact algorithms for small graphs, quantum for large - **DiracPGDHybrid**: Classical optimization with quantum refinement  **Strengths**: Best of both worlds, adaptive performance   **Limitations**: Added complexity in configuration"},{"location":"api/oracles/overview/#oracle-selection-guide","title":"Oracle Selection Guide","text":""},{"location":"api/oracles/overview/#by-problem-size","title":"By Problem Size","text":"Graph Size Recommended Oracle Rationale &lt; 15 nodes GurobiOracle Exact solutions fast 15-50 nodes JAX PGD (multi-restart) Good balance 50-200 nodes DiracOracle Quantum advantage &gt; 200 nodes Hybrid approaches Adaptive strategy"},{"location":"api/oracles/overview/#by-graph-properties","title":"By Graph Properties","text":"Graph Type Best Oracle Second Choice Dense JAX Mirror Descent DiracOracle Sparse JAX PGD GurobiOracle Regular GurobiOracle JAX PGD Scale-free DiracOracle JAX PGD"},{"location":"api/oracles/overview/#by-requirements","title":"By Requirements","text":"Requirement Oracle Choice Configuration Exact solutions GurobiOracle Default settings Speed JAX PGD Single restart Quality JAX PGD Many restarts Large scale DiracOracle High samples Production Hybrid Adaptive thresholds"},{"location":"api/oracles/overview/#common-usage-patterns","title":"Common Usage Patterns","text":""},{"location":"api/oracles/overview/#basic-oracle-usage","title":"Basic Oracle Usage","text":"<pre><code>import networkx as nx\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\n# Create graph\nG = nx.karate_club_graph()\n\n# Initialize oracle\noracle = ProjectedGradientDescentOracle()\n\n# Get clique number\nomega = oracle.get_omega(G)\nprint(f\"Clique number: {omega}\")\nprint(f\"Oracle calls made: {oracle.call_count}\")\n</code></pre>"},{"location":"api/oracles/overview/#multi-oracle-comparison","title":"Multi-Oracle Comparison","text":"<pre><code>from motzkinstraus.oracles import *\n\noracles = [\n    ProjectedGradientDescentOracle(num_restarts=5),\n    MirrorDescentOracle(num_restarts=5),\n    DiracOracle(num_samples=20)\n]\n\nresults = {}\nfor oracle in oracles:\n    omega = oracle.get_omega(G)\n    results[oracle.name] = {\n        'omega': omega,\n        'calls': oracle.call_count\n    }\n\nprint(results)\n</code></pre>"},{"location":"api/oracles/overview/#performance-monitoring","title":"Performance Monitoring","text":"<pre><code># Enable verbose mode for detailed tracking\noracle = ProjectedGradientDescentOracle(verbose=True)\noracle.verbose_oracle_calls = True\n\n# Track convergence\nomega = oracle.get_omega(G)\n\n# Access detailed metrics\nprint(f\"Final energy: {oracle.last_energy}\")\nprint(f\"Iterations: {oracle.last_iterations}\")\nprint(f\"Convergence history: {oracle.convergence_history}\")\n</code></pre>"},{"location":"api/oracles/overview/#error-handling","title":"Error Handling","text":"<pre><code>from motzkinstraus.exceptions import OracleError, SolverUnavailableError\n\ntry:\n    oracle = DiracOracle()  # May fail if Dirac not available\n    omega = oracle.get_omega(G)\nexcept SolverUnavailableError as e:\n    print(f\"Solver not available: {e}\")\n    # Fallback to available solver\n    oracle = ProjectedGradientDescentOracle()\n    omega = oracle.get_omega(G)\nexcept OracleError as e:\n    print(f\"Optimization failed: {e}\")\n</code></pre>"},{"location":"api/oracles/overview/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/oracles/overview/#automatic-oracle-selection","title":"Automatic Oracle Selection","text":"<pre><code>def get_best_oracle(graph, prefer_exact=True, prefer_quantum=False):\n    \"\"\"Select optimal oracle based on graph properties.\"\"\"\n    n = graph.number_of_nodes()\n    m = graph.number_of_edges()\n    density = 2 * m / (n * (n - 1)) if n &gt; 1 else 0\n\n    if n &lt; 15 and prefer_exact:\n        return GurobiOracle()\n    elif density &gt; 0.7:  # Dense graph\n        return MirrorDescentOracle(num_restarts=10)\n    elif n &gt; 100 and prefer_quantum:\n        return DiracOracle(num_samples=50)\n    else:\n        return ProjectedGradientDescentOracle(num_restarts=8)\n\n# Usage\noracle = get_best_oracle(G, prefer_exact=False, prefer_quantum=True)\n</code></pre>"},{"location":"api/oracles/overview/#parameter-optimization","title":"Parameter Optimization","text":"<pre><code>from sklearn.model_selection import ParameterGrid\n\n# Grid search for JAX PGD parameters\nparam_grid = {\n    'learning_rate': [0.01, 0.02, 0.05],\n    'num_restarts': [5, 10, 20],\n    'tolerance': [1e-6, 1e-7, 1e-8]\n}\n\nbest_oracle = None\nbest_score = -float('inf')\n\nfor params in ParameterGrid(param_grid):\n    oracle = ProjectedGradientDescentOracle(**params)\n    # Evaluate on validation graphs\n    score = evaluate_oracle(oracle, validation_graphs)\n    if score &gt; best_score:\n        best_score = score\n        best_oracle = oracle\n</code></pre>"},{"location":"api/oracles/overview/#oracle-metrics-and-benchmarking","title":"Oracle Metrics and Benchmarking","text":""},{"location":"api/oracles/overview/#standard-metrics","title":"Standard Metrics","text":"<ul> <li>Solution Quality: How close to optimal</li> <li>Convergence Rate: Iterations to convergence  </li> <li>Robustness: Success rate across graph types</li> <li>Scalability: Performance vs. problem size</li> </ul>"},{"location":"api/oracles/overview/#benchmarking-framework","title":"Benchmarking Framework","text":"<pre><code>from motzkinstraus.benchmarks import OracleBenchmark\n\nbenchmark = OracleBenchmark(\n    oracles=[\n        ProjectedGradientDescentOracle(),\n        MirrorDescentOracle(),\n        DiracOracle()\n    ],\n    graph_generators=[\n        nx.erdos_renyi_graph,\n        nx.barabasi_albert_graph,\n        nx.watts_strogatz_graph\n    ]\n)\n\nresults = benchmark.run(sizes=[10, 20, 50], repetitions=5)\nbenchmark.plot_results(results)\n</code></pre>"},{"location":"api/oracles/overview/#extending-the-oracle-framework","title":"Extending the Oracle Framework","text":""},{"location":"api/oracles/overview/#custom-oracle-implementation","title":"Custom Oracle Implementation","text":"<pre><code>from motzkinstraus.oracles.base import Oracle\n\nclass MyCustomOracle(Oracle):\n    def __init__(self, custom_param=1.0):\n        super().__init__()\n        self.custom_param = custom_param\n\n    @property\n    def name(self):\n        return \"MyCustom\"\n\n    @property\n    def is_available(self):\n        return True  # Check dependencies\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        # Implement your optimization algorithm\n        # Must return optimal value of 0.5 * x.T @ A @ x\n        pass\n</code></pre>"},{"location":"api/oracles/overview/#integration-with-external-solvers","title":"Integration with External Solvers","text":"<pre><code>class ExternalSolverOracle(Oracle):\n    def __init__(self, solver_url):\n        super().__init__()\n        self.solver_url = solver_url\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        # Send problem to external service\n        response = requests.post(self.solver_url, \n                               json={'matrix': adjacency_matrix.tolist()})\n        return response.json()['optimal_value']\n</code></pre>"},{"location":"api/oracles/overview/#oracle-composition-patterns","title":"Oracle Composition Patterns","text":""},{"location":"api/oracles/overview/#sequential-oracles","title":"Sequential Oracles","text":"<pre><code>class SequentialOracle(Oracle):\n    def __init__(self, oracles):\n        super().__init__()\n        self.oracles = oracles\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        best_value = -float('inf')\n        for oracle in self.oracles:\n            try:\n                value = oracle.solve_quadratic_program(adjacency_matrix)\n                best_value = max(best_value, value)\n            except OracleError:\n                continue\n        return best_value\n</code></pre>"},{"location":"api/oracles/overview/#ensemble-oracles","title":"Ensemble Oracles","text":"<pre><code>class EnsembleOracle(Oracle):\n    def __init__(self, oracles, weights=None):\n        super().__init__()\n        self.oracles = oracles\n        self.weights = weights or [1.0] * len(oracles)\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        values = []\n        for oracle in self.oracles:\n            value = oracle.solve_quadratic_program(adjacency_matrix)\n            values.append(value)\n\n        # Weighted average\n        return sum(w * v for w, v in zip(self.weights, values)) / sum(self.weights)\n</code></pre> <p>Next: Explore individual oracle documentation: - JAX Solvers - Gradient-based optimization methods - Dirac-3 Oracle - Quantum computing approach - Gurobi Oracle - Commercial solver integration - Hybrid Oracles - Combined approaches</p>"},{"location":"api/oracles/qp-solvers/","title":"Quadratic Programming Solvers","text":"<p>The Motzkin-Straus MIS solver provides a comprehensive suite of quadratic programming (QP) solvers to handle the non-convex optimization problem that lies at the heart of the theorem. Each solver offers different performance characteristics, precision guarantees, and computational complexity profiles.</p>"},{"location":"api/oracles/qp-solvers/#problem-formulation","title":"Problem Formulation","text":"<p>All solvers tackle the same fundamental optimization problem derived from the Motzkin-Straus theorem:</p> Standard QP Formulation  $$\\begin{align} \\text{maximize} \\quad &amp; \\frac{1}{2} x^T A x \\\\ \\text{subject to} \\quad &amp; \\sum_{i=1}^n x_i = 1 \\\\ &amp; x_i \\geq 0, \\quad i = 1, \\ldots, n \\end{align}$$  where $A$ is the adjacency matrix of the input graph and $x \\in \\mathbb{R}^n$ represents points on the probability simplex $\\Delta_n$."},{"location":"api/oracles/qp-solvers/#key-challenges","title":"Key Challenges","text":"<ul> <li>Non-convexity: The objective function \\(\\frac{1}{2} x^T A x\\) is generally non-convex for graph adjacency matrices</li> <li>Local optima: Standard optimization algorithms may converge to suboptimal solutions</li> <li>Constraint handling: Maintaining feasibility on the probability simplex throughout optimization</li> <li>Numerical precision: Floating-point errors can impact the final discrete result</li> </ul>"},{"location":"api/oracles/qp-solvers/#available-solvers","title":"Available Solvers","text":""},{"location":"api/oracles/qp-solvers/#1-jax-projected-gradient-descent-pgd","title":"1. JAX Projected Gradient Descent (PGD)","text":"#### ProjectedGradientDescentOracle  **Type**: First-order gradient-based optimization   **Backend**: JAX with JIT compilation   **Best for**: General-purpose optimization with good performance across graph types  **Mathematical Approach**: The oracle uses projected gradient descent with simplex projection:  1. **Gradient computation**: $g = A x$ 2. **Gradient step**: $y = x + \\alpha g$  3. **Simplex projection**: $x_{new} = \\Pi_{\\Delta_n}(y)$  **Key Features**: - Multi-restart strategy with Dirichlet initializations - Early stopping based on energy tolerance   - JIT-compiled optimization for performance - Complete convergence history tracking  **Parameters**:  learning_rate: float = 0.01 Step size for gradient descent  max_iterations: int = 2000 Maximum optimization iterations  num_restarts: int = 10 Number of random initializations  tolerance: float = 1e-6 Convergence tolerance for early stopping   **Complexity**: O(iterations \u00d7 n\u00b2)  **Example Usage**: <pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\noracle = ProjectedGradientDescentOracle(\n    learning_rate=0.02,\n    max_iterations=1000,\n    num_restarts=5,\n    tolerance=1e-7\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#2-jax-mirror-descent","title":"2. JAX Mirror Descent","text":"#### MirrorDescentOracle  **Type**: Exponentiated gradient method   **Backend**: JAX with entropic regularization   **Best for**: Simplex-constrained optimization with natural constraint handling  **Mathematical Approach**: Mirror descent uses the exponential map for simplex updates:  1. **Gradient computation**: $g = A x$ 2. **Log-space update**: $\\log x_{new} = \\log x + \\alpha g$ 3. **Normalization**: $x_{new} = \\frac{x_{new}}{\\sum_i x_{new,i}}$  The method naturally maintains simplex constraints through the exponential family structure.  **Key Features**: - Exponentiated gradient updates with numerical stabilization - Superior performance on simplex-constrained problems - Natural constraint satisfaction (no projection needed) - Adaptive step-size mechanisms  **Parameters**:  learning_rate: float = 0.005 Step size for exponentiated gradient (typically smaller than PGD)  max_iterations: int = 2000 Maximum optimization iterations  num_restarts: int = 10 Number of Dirichlet initializations   **Complexity**: O(iterations \u00d7 n\u00b2)  **Example Usage**: <pre><code>from motzkinstraus.oracles.jax_mirror import MirrorDescentOracle\n\noracle = MirrorDescentOracle(\n    learning_rate=0.008,\n    max_iterations=1500,\n    num_restarts=8\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#3-dirac-3-quantum-annealing","title":"3. Dirac-3 Quantum Annealing","text":"#### DiracOracle  **Type**: Quantum annealing / Photonic computing   **Backend**: QCi Dirac-3 continuous cloud solver   **Best for**: Large-scale problems and quantum-enhanced optimization  **Mathematical Approach**: The Dirac-3 system uses **photonic quantum computing** with temporal encoding:  - **Time-bin encoding**: Variables encoded in photon arrival times - **Quantum superposition**: Multiple solution candidates explored simultaneously   - **Quantum annealing**: Gradual evolution from quantum superposition to classical solution - **Quantum fluctuations**: Natural quantum noise helps escape local minima  **Key Features**: - True quantum computing backend (not simulation) - Advanced parameter control for quantum effects - Handles large-scale problems efficiently - Novel photonic hardware approach  **Parameters**:  num_samples: int = 100 Number of solution samples to request Range: 1-100 relax_schedule: int = 2 Quantum relaxation schedule controlling dissipation Range: {1,2,3,4} sum_constraint: int = 1 Constraint for solution variables sum Range: 1-10000 mean_photon_number: Optional[float] = None Average photons per time-bin (quantum coherence control) Range: 6.67\u00d710\u207b\u2075 to 6.67\u00d710\u207b\u00b3 quantum_fluctuation_coefficient: Optional[int] = None Quantum noise level for escaping local minima Range: 1-100   **Complexity**: O(quantum time)  **Quantum Physics Background**: The mean photon number controls quantum coherence in the time-bin modes, while the quantum fluctuation coefficient leverages Poisson noise from single-photon detection to enable exploration of the solution space.   **Example Usage**: <pre><code>from motzkinstraus.oracles.dirac import DiracOracle\n\noracle = DiracOracle(\n    num_samples=50,\n    relax_schedule=3,\n    mean_photon_number=0.002,          # Enhanced quantum coherence\n    quantum_fluctuation_coefficient=50  # Moderate quantum noise\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#4-gurobi-commercial-solver","title":"4. Gurobi Commercial Solver","text":"#### GurobiOracle  **Type**: Commercial non-convex quadratic programming   **Backend**: Gurobi Optimizer   **Best for**: High-precision solutions and production environments  **Mathematical Approach**: Gurobi employs sophisticated algorithms for non-convex QP:  - **Branch-and-bound**: Systematic exploration of solution space - **Cutting planes**: Tightening relaxations for better bounds   - **Heuristics**: Fast initial solutions and local search - **Presolving**: Problem reduction and reformulation  **Key Features**: - Industry-leading commercial solver - Guaranteed global optimality (when termination criteria met) - Advanced presolving and problem reformulation - Professional technical support  **Parameters**:  suppress_output: bool = True Whether to suppress Gurobi's detailed output logs   **Complexity**: O(n\u00b3) typical, exponential worst-case  **Requirements**: - Valid Gurobi license (academic or commercial) - `gurobipy` Python package installation  **Example Usage**: <pre><code>from motzkinstraus.oracles.gurobi import GurobiOracle\n\noracle = GurobiOracle(suppress_output=False)  # Show optimization progress\n</code></pre>"},{"location":"api/oracles/qp-solvers/#5-jax-frank-wolfe","title":"5. JAX Frank-Wolfe","text":"#### FrankWolfeOracle  **Type**: Projection-free first-order method   **Backend**: JAX with linear optimization oracles   **Best for**: Large-scale problems where projection is expensive  **Mathematical Approach**: The Frank-Wolfe algorithm avoids explicit projection:  1. **Linear approximation**: $\\min_{s \\in \\Delta_n} \\langle \\nabla f(x), s \\rangle$ 2. **Step computation**: $\\gamma = \\frac{2}{k+2}$ (line search or fixed) 3. **Convex combination**: $x_{new} = (1-\\gamma) x + \\gamma s$  **Key Features**: - Projection-free optimization (only linear minimization) - Sparse iterate sequences - Convergence rate guarantees - Memory-efficient for large problems  **Complexity**: O(iterations \u00d7 n\u00b2)"},{"location":"api/oracles/qp-solvers/#hybrid-approaches","title":"Hybrid Approaches","text":""},{"location":"api/oracles/qp-solvers/#diracnetworkxhybridoracle","title":"DiracNetworkXHybridOracle","text":"<p>Combines exact NetworkX algorithms with Dirac-3 quantum annealing:</p> <pre><code>from motzkinstraus.oracles.dirac_hybrid import DiracNetworkXHybridOracle\n\nhybrid_oracle = DiracNetworkXHybridOracle(\n    networkx_size_threshold=20,  # Use exact solver for small graphs\n    num_samples=30,\n    relax_schedule=2\n)\n</code></pre> <p>Strategy: - Small graphs (\u2264 threshold): Use exact NetworkX algorithms - Large graphs (&gt; threshold): Use Dirac-3 quantum annealing</p>"},{"location":"api/oracles/qp-solvers/#diracpgdhybridoracle","title":"DiracPGDHybridOracle","text":"<p>Combines JAX PGD with Dirac-3 for adaptive optimization:</p> <pre><code>from motzkinstraus.oracles.dirac_pgd_hybrid import DiracPGDHybridOracle\n\nhybrid_oracle = DiracPGDHybridOracle(\n    use_pgd_first=True,          # Try PGD before Dirac\n    pgd_time_limit=10.0,         # PGD timeout in seconds\n    dirac_num_samples=25\n)\n</code></pre> <p>Strategy: - Phase 1: Fast JAX PGD for initial solution - Phase 2: Dirac-3 quantum refinement if needed</p>"},{"location":"api/oracles/qp-solvers/#performance-comparison","title":"Performance Comparison","text":""},{"location":"api/oracles/qp-solvers/#computational-complexity","title":"Computational Complexity","text":"Solver Time Complexity Space Complexity Convergence JAX PGD O(iter \u00d7 n\u00b2) O(n\u00b2) First-order JAX Mirror O(iter \u00d7 n\u00b2) O(n\u00b2) First-order Dirac-3 O(quantum) O(n) Quantum annealing Gurobi O(n\u00b3) typical O(n\u00b2) Global optimum Frank-Wolfe O(iter \u00d7 n\u00b2) O(n) Projection-free"},{"location":"api/oracles/qp-solvers/#solution-quality-vs-speed-trade-offs","title":"Solution Quality vs Speed Trade-offs","text":"Gurobi (Global) Slowest 100% optimal Dirac-3 (Quantum) Fast 95%+ optimal JAX PGD (Multi-restart) Medium 90%+ optimal JAX Mirror (Single) Fast 80%+ optimal"},{"location":"api/oracles/qp-solvers/#graph-type-recommendations","title":"Graph Type Recommendations","text":"Graph Type Recommended Solver Rationale Small (&lt; 20 nodes) Gurobi Exact solutions feasible Dense graphs JAX Mirror Descent Better simplex handling Sparse graphs JAX PGD Efficient gradient computation Large scale (&gt; 100 nodes) Dirac-3 Quantum advantage Production systems Hybrid approaches Adaptive performance"},{"location":"api/oracles/qp-solvers/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"api/oracles/qp-solvers/#multi-restart-strategies","title":"Multi-restart Strategies","text":"<p>For non-convex optimization, multiple random initializations are crucial:</p> <pre><code># High-quality configuration\noracle = ProjectedGradientDescentOracle(\n    num_restarts=20,           # More restarts = better solution quality\n    dirichlet_alpha=0.5,       # Concentrated initialization\n    tolerance=1e-8             # Tight convergence\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#quantum-parameter-tuning","title":"Quantum Parameter Tuning","text":"<p>Fine-tune quantum effects for specific problem types:</p> <pre><code># For highly connected graphs (many local minima)\nquantum_oracle = DiracOracle(\n    mean_photon_number=0.001,           # Lower = more quantum coherence\n    quantum_fluctuation_coefficient=80   # Higher = more exploration\n)\n\n# For sparse graphs (fewer local minima) \nquantum_oracle = DiracOracle(\n    mean_photon_number=0.005,           # Higher = faster convergence\n    quantum_fluctuation_coefficient=20  # Lower = more exploitation\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#convergence-monitoring","title":"Convergence Monitoring","text":"<p>All JAX-based solvers provide detailed convergence information:</p> <pre><code>oracle = ProjectedGradientDescentOracle(verbose=True)\nresult = oracle.solve_quadratic_program(adjacency_matrix)\n\n# Access convergence history\nprint(f\"Converged in {oracle.last_iterations} iterations\")\nprint(f\"Final energy: {oracle.last_energy}\")\nprint(f\"Convergence history: {oracle.convergence_history}\")\n</code></pre>"},{"location":"api/oracles/qp-solvers/#error-handling-and-robustness","title":"Error Handling and Robustness","text":""},{"location":"api/oracles/qp-solvers/#numerical-stability","title":"Numerical Stability","text":"<p>All solvers implement robust numerical handling:</p> <ul> <li>Gradient clipping: Prevents explosive gradients</li> <li>Epsilon regularization: Handles degenerate cases  </li> <li>Overflow protection: Guards against numerical overflow</li> <li>Convergence validation: Verifies solution quality</li> </ul>"},{"location":"api/oracles/qp-solvers/#fallback-mechanisms","title":"Fallback Mechanisms","text":"<pre><code>from motzkinstraus.oracles import get_best_available_oracle\n\n# Automatic solver selection based on availability\noracle = get_best_available_oracle(\n    prefer_quantum=True,     # Try Dirac-3 first\n    require_exact=False      # Allow approximate solvers\n)\n</code></pre>"},{"location":"api/oracles/qp-solvers/#future-developments","title":"Future Developments","text":""},{"location":"api/oracles/qp-solvers/#planned-enhancements","title":"Planned Enhancements","text":"<ul> <li>Quantum-classical hybrid algorithms: Advanced integration patterns</li> <li>Adaptive parameter selection: ML-guided hyperparameter tuning</li> <li>Distributed computing: Multi-GPU and cluster support  </li> <li>Problem-specific solvers: Specialized algorithms for graph families</li> </ul>"},{"location":"api/oracles/qp-solvers/#research-directions","title":"Research Directions","text":"<ul> <li>Quantum advantage characterization: When does quantum computing help?</li> <li>Approximation guarantees: Theoretical bounds for approximate solvers</li> <li>Scalability analysis: Performance on massive graphs (10K+ nodes)</li> </ul> <p>Next Steps: Explore specific solver documentation or learn about hybrid approaches for combining multiple methods.</p>"},{"location":"examples/omega-computation/","title":"Computing \u03c9(G): Maximum Clique Size Tutorial","text":"<p>This tutorial teaches you how to compute the maximum clique size \u03c9(G) using the <code>motzkinstraus</code> package. We'll start with simple examples and build up to advanced usage, connecting the theoretical Motzkin-Straus theorem to practical implementation.</p>"},{"location":"examples/omega-computation/#mathematical-context","title":"Mathematical Context","text":"<p>The clique number \u03c9(G) is the size of the largest complete subgraph (clique) in graph G:</p> <ul> <li>Complete Graph K\u2085: \u03c9(K\u2085) = 5 (all vertices form one clique)</li> <li>Cycle Graph C\u2085: \u03c9(C\u2085) = 2 (any two adjacent vertices)</li> <li>Tree: \u03c9(Tree) = 2 (any edge forms a clique)</li> <li>Independent Set: \u03c9(Empty) = 1 (no edges, so single vertices only)</li> </ul> <p>The Motzkin-Straus theorem enables us to compute \u03c9(G) by solving a continuous optimization problem instead of exhaustive search.</p>"},{"location":"examples/omega-computation/#quick-start","title":"Quick Start","text":"<p>Get \u03c9(G) in just 3 lines of code:</p> <pre><code>import networkx as nx\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\n# Create a graph\ngraph = nx.complete_graph(5)  # K\u2085 has \u03c9(G) = 5\n\n# Compute clique number\noracle = ProjectedGradientDescentOracle()\nomega = oracle.get_omega(graph)\nprint(f\"\u03c9(G) = {omega}\")  # Output: \u03c9(G) = 5\n</code></pre> <p>That's it! The oracle automatically handles the Motzkin-Straus optimization and returns the clique number.</p>"},{"location":"examples/omega-computation/#which-oracle-should-i-use","title":"Which Oracle Should I Use?","text":"<p>The library provides multiple solver backends, called oracles. Each has unique strengths for different scenarios:</p> Oracle Solver Type Accuracy Speed Best For JAX Oracles Continuous Optim. Approximate Fast (GPU support) Large graphs, quick estimates, research MILP Oracles Integer Programming Exact Slow (Exponential) Small-medium graphs where proof of optimality is required NetworkX Oracle Exact Algorithm Exact Very Slow (Exponential) Small graphs, validation, educational purposes Dirac Oracle Quantum Inspired Approximate Varies (Hardware dep.) Experimental use, exploring quantum approaches"},{"location":"examples/omega-computation/#quick-decision-guide","title":"Quick Decision Guide","text":"<ul> <li>For most applications: Start with <code>ProjectedGradientDescentOracle</code> (JAX)</li> <li>When you need guaranteed correctness: Use MILP solvers and be prepared for longer runtimes</li> <li>For learning or validating small graphs: NetworkX is simplest</li> <li>For research into quantum methods: Explore the Dirac oracle</li> </ul>"},{"location":"examples/omega-computation/#understanding-the-oracles","title":"Understanding the Oracles","text":""},{"location":"examples/omega-computation/#jax-oracles-fast-continuous-optimization","title":"JAX Oracles: Fast Continuous Optimization","text":"<p>JAX oracles implement the Motzkin-Straus theorem directly using modern optimization algorithms:</p> <pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.oracles.jax_mirror import MirrorDescentOracle\n\n# Projected Gradient Descent (recommended for most cases)\npgd_oracle = ProjectedGradientDescentOracle(\n    learning_rate=0.02,\n    max_iterations=500,\n    num_restarts=5,\n    tolerance=1e-6\n)\n\n# Mirror Descent (alternative optimization approach)\nmirror_oracle = MirrorDescentOracle(\n    learning_rate=0.01,\n    max_iterations=500,\n    num_restarts=5\n)\n\n# Both work the same way\ngraph = nx.erdos_renyi_graph(50, 0.3)\nomega_pgd = pgd_oracle.get_omega(graph)\nomega_mirror = mirror_oracle.get_omega(graph)\n\nprint(f\"PGD result: \u03c9(G) = {omega_pgd}\")\nprint(f\"Mirror Descent result: \u03c9(G) = {omega_mirror}\")\n</code></pre> <p>How it works: These oracles solve the optimization problem <code>max x^T A x</code> subject to <code>x \u2208 \u0394\u2099</code> (probability simplex), then use the Motzkin-Straus formula <code>\u03c9(G) = 1/(1 - 2M)</code> where M is the optimal value.</p>"},{"location":"examples/omega-computation/#milp-oracles-exact-solutions","title":"MILP Oracles: Exact Solutions","text":"<p>MILP (Mixed-Integer Linear Programming) oracles provide provably optimal results by formulating clique detection as an integer program:</p> <pre><code>from motzkinstraus.oracles.gurobi import GurobiOracle\nfrom motzkinstraus.solvers.scipy_milp import get_clique_number_scipy\n\n# Gurobi Oracle (requires Gurobi license)\nif GurobiOracle.is_available():\n    gurobi_oracle = GurobiOracle(suppress_output=True)\n    omega_exact = gurobi_oracle.get_omega(graph)\n    print(f\"Gurobi (exact): \u03c9(G) = {omega_exact}\")\n\n# SciPy MILP (free alternative)\nomega_scipy = get_clique_number_scipy(graph)\nprint(f\"SciPy MILP (exact): \u03c9(G) = {omega_scipy}\")\n</code></pre> <p>When to use: Small to medium graphs (&lt; 100 nodes) where you need mathematical proof of optimality. Runtime grows exponentially with graph size.</p>"},{"location":"examples/omega-computation/#networkx-oracle-simple-baseline","title":"NetworkX Oracle: Simple Baseline","text":"<pre><code>import networkx as nx\n\n# Built-in NetworkX exact solver\nomega_nx = nx.graph_clique_number(graph)\nprint(f\"NetworkX (exact): \u03c9(G) = {omega_nx}\")\n</code></pre> <p>When to use: Educational purposes, small graphs (&lt; 20 nodes), or as a validation baseline for other methods.</p>"},{"location":"examples/omega-computation/#dirac-oracle-quantum-inspired-optimization","title":"Dirac Oracle: Quantum-Inspired Optimization","text":"<p>The Dirac oracle explores quantum annealing approaches to optimization:</p> <pre><code>from motzkinstraus.oracles.dirac import DiracOracle\n\n# Quantum-inspired solver\ndirac_oracle = DiracOracle(\n    num_samples=50,\n    relax_schedule=3,\n    mean_photon_number=0.0015,\n    quantum_fluctuation_coefficient=3\n)\n\nif dirac_oracle.is_available:\n    omega_quantum = dirac_oracle.get_omega(graph)\n    print(f\"Dirac (quantum): \u03c9(G) = {omega_quantum}\")\n</code></pre> <p>When to use: Research into quantum computing applications, experimenting with novel optimization paradigms, or when classical methods struggle with specific graph structures.</p>"},{"location":"examples/omega-computation/#practical-workshop-comparing-methods","title":"Practical Workshop: Comparing Methods","text":"<p>Let's compare different approaches on real examples:</p> <pre><code>import networkx as nx\nimport time\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.solvers.scipy_milp import get_clique_number_scipy\n\ndef compare_methods(graph, graph_name):\n    \"\"\"Compare different \u03c9(G) computation methods.\"\"\"\n    print(f\"\\n=== {graph_name} ===\")\n    print(f\"Nodes: {graph.number_of_nodes()}, Edges: {graph.number_of_edges()}\")\n\n    results = {}\n\n    # JAX Oracle (fast, approximate)\n    oracle = ProjectedGradientDescentOracle(num_restarts=3, verbose=False)\n    start = time.time()\n    omega_jax = oracle.get_omega(graph)\n    time_jax = time.time() - start\n    results['JAX PGD'] = (omega_jax, time_jax, 'Approximate')\n\n    # NetworkX (exact, slow)\n    if graph.number_of_nodes() &lt;= 15:  # Only for small graphs\n        start = time.time()\n        omega_nx = nx.graph_clique_number(graph)\n        time_nx = time.time() - start\n        results['NetworkX'] = (omega_nx, time_nx, 'Exact')\n\n    # SciPy MILP (exact, moderate speed)\n    if graph.number_of_nodes() &lt;= 25:  # Only for small-medium graphs\n        start = time.time()\n        omega_milp = get_clique_number_scipy(graph)\n        time_milp = time.time() - start\n        results['SciPy MILP'] = (omega_milp, time_milp, 'Exact')\n\n    # Display results\n    print(f\"{'Method':&lt;12} {'\u03c9(G)':&lt;6} {'Time(s)':&lt;10} {'Type':&lt;12}\")\n    print(\"-\" * 40)\n    for method, (omega, runtime, type_) in results.items():\n        print(f\"{method:&lt;12} {omega:&lt;6} {runtime:&lt;10.4f} {type_:&lt;12}\")\n\n    return results\n\n# Test on different graph types\nexamples = [\n    (nx.complete_graph(8), \"Complete K\u2088\"),\n    (nx.cycle_graph(10), \"Cycle C\u2081\u2080\"),\n    (nx.erdos_renyi_graph(20, 0.4), \"Erd\u0151s-R\u00e9nyi(20, 0.4)\"),\n    (nx.karate_club_graph(), \"Karate Club\"),\n]\n\nfor graph, name in examples:\n    compare_methods(graph, name)\n</code></pre>"},{"location":"examples/omega-computation/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"examples/omega-computation/#tuning-jax-oracles","title":"Tuning JAX Oracles","text":"<p>The JAX oracles support extensive configuration to optimize performance:</p> <pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\n# High-precision configuration for accuracy\nprecise_oracle = ProjectedGradientDescentOracle(\n    learning_rate=0.01,        # Smaller steps for stability\n    max_iterations=2000,       # More iterations for convergence\n    num_restarts=10,           # Multiple restarts to avoid local optima\n    tolerance=1e-8,            # Tight convergence criterion\n    verbose=True               # Show optimization progress\n)\n\n# Fast configuration for quick estimates\nfast_oracle = ProjectedGradientDescentOracle(\n    learning_rate=0.05,        # Larger steps for speed\n    max_iterations=200,        # Fewer iterations\n    num_restarts=3,            # Fewer restarts\n    tolerance=1e-4,            # Looser convergence\n    verbose=False\n)\n\n# GPU configuration (if available)\ngpu_oracle = ProjectedGradientDescentOracle(\n    learning_rate=0.02,\n    max_iterations=1000,\n    num_restarts=8,\n    use_gpu=True               # Enable GPU acceleration\n)\n</code></pre>"},{"location":"examples/omega-computation/#configuration-parameters-guide","title":"Configuration Parameters Guide","text":"Parameter JAX Oracles Description <code>learning_rate</code> PGD, Mirror Step size for optimization (0.001-0.1 typical) <code>max_iterations</code> PGD, Mirror Maximum optimization steps (100-2000 typical) <code>num_restarts</code> PGD, Mirror Random restarts to avoid local optima (1-20 typical) <code>tolerance</code> PGD, Mirror Convergence threshold (1e-8 to 1e-4 typical) <code>verbose</code> PGD, Mirror Show detailed optimization output Parameter MILP Oracles Description <code>solver</code> Gurobi, SciPy Backend solver ('GUROBI', 'SCIPY', etc.) <code>time_limit</code> Gurobi Maximum solve time in seconds <code>suppress_output</code> Gurobi Hide solver console output Parameter Dirac Oracle Description <code>num_samples</code> Dirac Number of quantum annealing samples <code>relax_schedule</code> Dirac Relaxation schedule parameter <code>mean_photon_number</code> Dirac Quantum photon number setting"},{"location":"examples/omega-computation/#working-with-dimacs-files","title":"Working with DIMACS Files","text":"<p>Many graph theory benchmarks use the DIMACS format. Here's how to compute \u03c9(G) for DIMACS files:</p> <pre><code>import networkx as nx\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\n\ndef read_dimacs_graph(filename):\n    \"\"\"Read a graph from DIMACS format.\"\"\"\n    graph = nx.Graph()\n\n    with open(filename, 'r') as f:\n        for line in f:\n            if line.startswith('p edge'):\n                # Problem line: p edge &lt;num_vertices&gt; &lt;num_edges&gt;\n                parts = line.strip().split()\n                num_vertices = int(parts[2])\n                graph.add_nodes_from(range(1, num_vertices + 1))\n            elif line.startswith('e'):\n                # Edge line: e &lt;vertex1&gt; &lt;vertex2&gt;\n                parts = line.strip().split()\n                u, v = int(parts[1]), int(parts[2])\n                graph.add_edge(u, v)\n\n    return graph\n\ndef process_dimacs_file(filename):\n    \"\"\"Process a DIMACS file and compute \u03c9(G).\"\"\"\n    print(f\"Processing {filename}...\")\n\n    # Load graph\n    graph = read_dimacs_graph(filename)\n    print(f\"Loaded graph: {graph.number_of_nodes()} nodes, {graph.number_of_edges()} edges\")\n\n    # Compute \u03c9(G) using JAX oracle\n    oracle = ProjectedGradientDescentOracle(num_restarts=5, verbose=False)\n    start_time = time.time()\n    omega = oracle.get_omega(graph)\n    runtime = time.time() - start_time\n\n    print(f\"Result: \u03c9(G) = {omega} (computed in {runtime:.3f}s)\")\n    return omega, runtime\n\n# Example usage\n# omega, time = process_dimacs_file(\"path/to/graph.dimacs\")\n</code></pre>"},{"location":"examples/omega-computation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"examples/omega-computation/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>Issue: JAX oracle returns obviously wrong results Solution: Increase <code>num_restarts</code> and <code>max_iterations</code>. The optimization may be stuck in local optima.</p> <pre><code># Instead of default settings\noracle = ProjectedGradientDescentOracle()\n\n# Try this for difficult graphs\noracle = ProjectedGradientDescentOracle(\n    num_restarts=10,\n    max_iterations=1000,\n    tolerance=1e-7\n)\n</code></pre> <p>Issue: MILP solver takes too long Solution: Set time limits or switch to approximate methods for large graphs.</p> <pre><code>from motzkinstraus.oracles.gurobi import GurobiOracle\n\n# Set 60-second time limit\noracle = GurobiOracle(time_limit=60)\n</code></pre> <p>Issue: \"Oracle not available\" errors Solution: Check dependencies and installation.</p> <pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.oracles.gurobi import GurobiOracle\n\n# Check availability before using\npgd_oracle = ProjectedGradientDescentOracle()\nif pgd_oracle.is_available:\n    print(\"JAX PGD Oracle available\")\nelse:\n    print(\"JAX PGD Oracle not available - check JAX installation\")\n\nif GurobiOracle.is_available():\n    print(\"Gurobi Oracle available\")\nelse:\n    print(\"Gurobi Oracle not available - check license\")\n</code></pre>"},{"location":"examples/omega-computation/#validation-and-verification","title":"Validation and Verification","text":"<p>Always validate approximate results against exact methods when possible:</p> <pre><code>def validate_omega_result(graph, approximate_omega, tolerance=0):\n    \"\"\"Validate approximate \u03c9(G) against exact methods.\"\"\"\n    if graph.number_of_nodes() &lt;= 15:\n        exact_omega = nx.graph_clique_number(graph)\n        diff = abs(approximate_omega - exact_omega)\n\n        if diff &lt;= tolerance:\n            print(f\"\u2705 Validation passed: {approximate_omega} \u2248 {exact_omega}\")\n            return True\n        else:\n            print(f\"\u26a0\ufe0f Validation failed: {approximate_omega} vs {exact_omega} (diff: {diff})\")\n            return False\n    else:\n        print(f\"\u26a1 Graph too large for exact validation ({graph.number_of_nodes()} nodes)\")\n        return None\n\n# Example validation\ngraph = nx.erdos_renyi_graph(12, 0.4)\noracle = ProjectedGradientDescentOracle(num_restarts=5)\nomega_approx = oracle.get_omega(graph)\nvalidate_omega_result(graph, omega_approx)\n</code></pre>"},{"location":"examples/omega-computation/#summary","title":"Summary","text":"<p>You now know how to:</p> <ol> <li>Compute \u03c9(G) using the unified <code>get_omega()</code> interface</li> <li>Choose the right oracle based on your accuracy/speed requirements</li> <li>Configure oracles for optimal performance on your graphs</li> <li>Validate results using multiple methods</li> <li>Handle real-world data including DIMACS format files</li> </ol> <p>The <code>motzkinstraus</code> package transforms the theoretical elegance of the Motzkin-Straus theorem into practical tools for solving maximum clique problems. Whether you need fast approximations for large-scale analysis or exact solutions for critical applications, there's an oracle designed for your needs.</p>"},{"location":"examples/omega-computation/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the Maximum Independent Set tutorial to learn about the dual problem</li> <li>Read about oracle implementation details </li> <li>Try the Dirac quantum oracle guide for cutting-edge approaches</li> <li>Check out performance tuning tips for large-scale applications</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide covers installing the Motzkin-Straus MIS Solver and its dependencies across different environments and use cases.</p>"},{"location":"getting-started/installation/#quick-installation","title":"Quick Installation","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>uv is the fastest Python package manager and our recommended installation method:</p> <pre><code># Clone the repository\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\n\n# Install with uv\nuv sync\n\n# Activate the virtual environment\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code># Clone the repository\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\n\n# Create virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#dependency-groups","title":"Dependency Groups","text":"<p>The project uses dependency groups for different use cases:</p>"},{"location":"getting-started/installation/#core-dependencies-default","title":"Core Dependencies (Default)","text":"<pre><code>uv sync  # Installs core dependencies only\n</code></pre> <p>Includes: - NetworkX for graph operations - NumPy for numerical computing - JAX for gradient-based optimization - SciPy for scientific computing</p>"},{"location":"getting-started/installation/#documentation","title":"Documentation","text":"<pre><code>uv sync --group docs\n</code></pre> <p>Includes: - MkDocs with Material theme - Mathematical extensions (KaTeX) - Jupyter notebook support</p>"},{"location":"getting-started/installation/#development","title":"Development","text":"<pre><code>uv sync --group dev\n</code></pre> <p>Includes: - Testing frameworks (pytest) - Code formatting (black, isort) - Type checking (mypy) - Linting (ruff)</p>"},{"location":"getting-started/installation/#all-dependencies","title":"All Dependencies","text":"<pre><code>uv sync --all-groups\n</code></pre>"},{"location":"getting-started/installation/#optional-solver-dependencies","title":"Optional Solver Dependencies","text":""},{"location":"getting-started/installation/#dirac-3-quantum-computing","title":"Dirac-3 Quantum Computing","text":"<p>For quantum annealing capabilities:</p> <pre><code>pip install qci-client eqc-models\n</code></pre> <p>Requirements: - QCi account with Dirac-3 allocation - Valid authentication credentials</p> <p>Setup: <pre><code># Configure QCi credentials\nexport QCI_TOKEN=\"your_token_here\"\n# Or create ~/.qci/config.json with authentication\n</code></pre></p>"},{"location":"getting-started/installation/#gurobi-commercial-solver","title":"Gurobi Commercial Solver","text":"<p>For exact optimization:</p> <pre><code>pip install gurobipy\n</code></pre> <p>Requirements: - Valid Gurobi license (academic or commercial) - License file or network license server</p> <p>Setup: <pre><code># Academic license\ngrbgetkey your_license_key\n\n# Or set environment variable\nexport GRB_LICENSE_FILE=/path/to/gurobi.lic\n</code></pre></p>"},{"location":"getting-started/installation/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"getting-started/installation/#linux","title":"Linux","text":"<pre><code># Ubuntu/Debian\nsudo apt update\nsudo apt install python3-dev python3-venv git\n\n# Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone and install\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install Homebrew (if not already installed)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install Python and git\nbrew install python git\n\n# Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone and install\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<p>Using PowerShell:</p> <pre><code># Install Python from Microsoft Store or python.org\n# Install Git from git-scm.com\n\n# Install uv\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Clone and install\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#hardware-acceleration","title":"Hardware Acceleration","text":""},{"location":"getting-started/installation/#gpu-support-nvidia","title":"GPU Support (NVIDIA)","text":"<p>For accelerated JAX operations:</p> <pre><code># Install CUDA-enabled JAX\npip install \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n\n# Verify GPU availability\npython -c \"import jax; print(f'Devices: {jax.devices()}')\"\n</code></pre>"},{"location":"getting-started/installation/#apple-silicon-m1m2","title":"Apple Silicon (M1/M2)","text":"<p>JAX automatically uses Metal acceleration:</p> <pre><code># Standard installation works\nuv sync\n\n# Verify Metal backend\npython -c \"import jax; print(f'Backend: {jax.default_backend()}')\"\n</code></pre>"},{"location":"getting-started/installation/#docker-installation","title":"Docker Installation","text":""},{"location":"getting-started/installation/#pre-built-image","title":"Pre-built Image","text":"<pre><code># Pull and run the container\ndocker pull ghcr.io/your-org/motzkinstraus:latest\ndocker run -it --rm ghcr.io/your-org/motzkinstraus:latest\n</code></pre>"},{"location":"getting-started/installation/#build-from-source","title":"Build from Source","text":"<pre><code># Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\nCOPY . .\n\nRUN pip install uv\nRUN uv sync --no-dev\n\nENTRYPOINT [\"python\", \"-m\", \"motzkinstraus\"]\n</code></pre> <pre><code># Build and run\ndocker build -t motzkinstraus .\ndocker run -it --rm motzkinstraus\n</code></pre>"},{"location":"getting-started/installation/#condamamba-installation","title":"Conda/Mamba Installation","text":"<pre><code># Create environment\nconda create -n motzkinstraus python=3.11\nconda activate motzkinstraus\n\n# Install from conda-forge\nconda install -c conda-forge networkx numpy scipy jax\n\n# Install package\ngit clone https://github.com/your-org/MotzkinStraus.git\ncd MotzkinStraus\npip install -e .\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing to the project:</p> <pre><code># Clone your fork\ngit clone https://github.com/your-username/MotzkinStraus.git\ncd MotzkinStraus\n\n# Install all development dependencies\nuv sync --all-groups\n\n# Install pre-commit hooks\npre-commit install\n\n# Run tests to verify installation\npytest tests/\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":""},{"location":"getting-started/installation/#basic-functionality-test","title":"Basic Functionality Test","text":"<pre><code>import networkx as nx\nfrom motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.algorithms import find_mis_with_oracle\n\n# Create test graph\nG = nx.cycle_graph(6)\n\n# Test basic oracle\noracle = ProjectedGradientDescentOracle()\nomega = oracle.get_omega(G)\nprint(f\"Clique number: {omega}\")  # Should be 2\n\n# Test MIS algorithm\nmis_set, calls = find_mis_with_oracle(G, oracle)\nprint(f\"MIS size: {len(mis_set)}\")  # Should be 3\nprint(f\"Oracle calls: {calls}\")\n</code></pre>"},{"location":"getting-started/installation/#solver-availability-check","title":"Solver Availability Check","text":"<pre><code>from motzkinstraus.oracles import check_solver_availability\n\n# Check which solvers are available\navailability = check_solver_availability()\nfor solver, available in availability.items():\n    status = \"\u2713\" if available else \"\u2717\"\n    print(f\"{status} {solver}\")\n</code></pre>"},{"location":"getting-started/installation/#performance-benchmark","title":"Performance Benchmark","text":"<pre><code>from motzkinstraus.benchmarks import quick_benchmark\n\n# Run quick performance test\nresults = quick_benchmark(\n    graph_sizes=[10, 20, 30],\n    num_trials=3\n)\nprint(f\"Benchmark completed: {results}\")\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-installation-issues","title":"Common Installation Issues","text":""},{"location":"getting-started/installation/#jax-installation-problems","title":"JAX Installation Problems","text":"<pre><code># Clear JAX cache\nrm -rf ~/.cache/jax_cache/\n\n# Reinstall with specific version\npip install --upgrade \"jax==0.4.20\" \"jaxlib==0.4.20\"\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<pre><code># Check Python path\nimport sys\nprint(sys.path)\n\n# Verify installation\nimport pkg_resources\nprint(pkg_resources.get_distribution('motzkinstraus'))\n</code></pre>"},{"location":"getting-started/installation/#permission-issues-linuxmacos","title":"Permission Issues (Linux/macOS)","text":"<pre><code># Fix ownership\nsudo chown -R $USER:$USER ~/.local/\n\n# Use user installation\npip install --user -e .\n</code></pre>"},{"location":"getting-started/installation/#dependency-conflicts","title":"Dependency Conflicts","text":"<pre><code># Check for conflicts\nuv pip check\n\n# Create clean environment\nuv venv --clean\nuv sync\n</code></pre>"},{"location":"getting-started/installation/#performance-issues","title":"Performance Issues","text":"<pre><code># Check JAX compilation\nimport jax\nprint(f\"JAX backend: {jax.default_backend()}\")\nprint(f\"Available devices: {jax.devices()}\")\n\n# Verify NumPy BLAS\nimport numpy as np\nnp.show_config()\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After successful installation:</p> <ol> <li>Quick Start - Basic usage examples</li> <li>Examples - Comprehensive examples</li> <li>API Documentation - Detailed reference</li> <li>Performance Tuning - Optimization tips</li> </ol>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter installation issues:</p> <ul> <li>Documentation: Check the troubleshooting guide</li> <li>GitHub Issues: Report installation problems</li> <li>Discussions: Community support</li> </ul>"},{"location":"getting-started/installation/#system-requirements","title":"System Requirements","text":""},{"location":"getting-started/installation/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Python: 3.9 or higher</li> <li>RAM: 4GB minimum, 8GB recommended</li> <li>Storage: 1GB for installation, additional space for data</li> <li>OS: Linux, macOS, Windows (64-bit)</li> </ul>"},{"location":"getting-started/installation/#recommended-requirements","title":"Recommended Requirements","text":"<ul> <li>Python: 3.11 or higher</li> <li>RAM: 16GB for large-scale problems</li> <li>GPU: NVIDIA GPU with CUDA support (optional)</li> <li>Storage: SSD for better I/O performance</li> </ul>"},{"location":"getting-started/installation/#tested-platforms","title":"Tested Platforms","text":"Platform Python Versions Status Ubuntu 22.04 3.9, 3.10, 3.11, 3.12 \u2705 Fully supported macOS 13+ 3.10, 3.11, 3.12 \u2705 Fully supported Windows 11 3.9, 3.10, 3.11 \u2705 Fully supported CentOS 8 3.9, 3.10 \u26a0\ufe0f Limited testing <p>Ready to start? Continue with the Quick Start Guide to learn basic usage patterns.</p>"},{"location":"guides/dirac-configuration/","title":"Dirac-3 Configuration Guide","text":"<p>This comprehensive guide covers configuring the Dirac-3 quantum oracle for optimal performance across different problem types and requirements.</p>"},{"location":"guides/dirac-configuration/#understanding-dirac-3-parameters","title":"Understanding Dirac-3 Parameters","text":""},{"location":"guides/dirac-configuration/#core-parameters-overview","title":"Core Parameters Overview","text":"<p>The Dirac-3 oracle provides fine-grained control over quantum computing parameters:</p> <pre><code>DiracOracle(\n    num_samples=100,                            # Quantum measurement samples\n    relax_schedule=2,                          # Annealing schedule {1,2,3,4}\n    sum_constraint=1,                          # Simplex constraint value\n    solution_precision=0.001,                  # Continuous solution precision\n    mean_photon_number=None,                   # Quantum coherence control\n    quantum_fluctuation_coefficient=None       # Quantum noise level\n)\n</code></pre>"},{"location":"guides/dirac-configuration/#quantum-physics-background","title":"Quantum Physics Background","text":"<p>Understanding the physics helps optimize performance:</p>  **Photonic Quantum Computing**: Dirac-3 encodes optimization variables in photon arrival times using temporal multiplexing. This approach naturally handles continuous optimization problems like the Motzkin-Straus QP."},{"location":"guides/dirac-configuration/#parameter-tuning-strategies","title":"Parameter Tuning Strategies","text":""},{"location":"guides/dirac-configuration/#1-relaxation-schedule-selection","title":"1. Relaxation Schedule Selection","text":"<p>The relaxation schedule controls the quantum annealing process:</p> Schedule Dissipation Quality Speed Best For 1 High Good Fast Quick approximations 2 Medium-High Better Medium Balanced performance 3 Medium-Low High Slow Quality solutions 4 Low Highest Slowest Critical accuracy"},{"location":"guides/dirac-configuration/#configuration-examples","title":"Configuration Examples","text":"<pre><code># Fast approximation (research exploration)\nfast_oracle = DiracOracle(\n    relax_schedule=1,\n    num_samples=20\n)\n\n# Production quality (balanced)\nproduction_oracle = DiracOracle(\n    relax_schedule=2,\n    num_samples=50\n)\n\n# Research quality (best solutions)\nresearch_oracle = DiracOracle(\n    relax_schedule=4,\n    num_samples=100\n)\n</code></pre>"},{"location":"guides/dirac-configuration/#2-sample-count-optimization","title":"2. Sample Count Optimization","text":"<p>More samples improve solution quality but increase computation time:</p> <pre><code>def optimize_sample_count(graph, time_budget_seconds=60):\n    \"\"\"Find optimal sample count within time budget.\"\"\"\n\n    base_samples = 10\n    max_samples = 200\n\n    # Estimate time per sample with small test\n    test_oracle = DiracOracle(num_samples=base_samples, relax_schedule=1)\n    start_time = time.time()\n    test_oracle.get_omega(graph)\n    time_per_sample = (time.time() - start_time) / base_samples\n\n    # Calculate optimal sample count\n    optimal_samples = min(max_samples, int(time_budget_seconds / time_per_sample))\n\n    return DiracOracle(\n        num_samples=optimal_samples,\n        relax_schedule=2  # Balanced quality\n    )\n</code></pre>"},{"location":"guides/dirac-configuration/#3-advanced-quantum-parameters","title":"3. Advanced Quantum Parameters","text":""},{"location":"guides/dirac-configuration/#mean-photon-number-tuning","title":"Mean Photon Number Tuning","text":"<p>Controls quantum coherence strength:</p> <pre><code>def select_photon_number(problem_type, graph_density):\n    \"\"\"Select optimal mean photon number.\"\"\"\n\n    if problem_type == \"exploration\":\n        return 0.0001  # Maximum quantum coherence\n    elif problem_type == \"exploitation\":\n        return 0.005   # More classical behavior\n\n    # Density-based selection\n    if graph_density &gt; 0.7:  # Dense graphs\n        return 0.0003  # Strong coherence for complex landscapes\n    elif graph_density &lt; 0.3:  # Sparse graphs  \n        return 0.002   # Moderate coherence\n    else:\n        return 0.001   # Default for medium density\n</code></pre>"},{"location":"guides/dirac-configuration/#quantum-fluctuation-coefficient","title":"Quantum Fluctuation Coefficient","text":"<p>Controls exploration vs exploitation balance:</p> <pre><code>def select_fluctuation_coefficient(optimization_landscape):\n    \"\"\"Select quantum fluctuation based on problem complexity.\"\"\"\n\n    if optimization_landscape == \"many_local_minima\":\n        return 90  # High exploration\n    elif optimization_landscape == \"few_local_minima\":\n        return 20  # Low exploration  \n    elif optimization_landscape == \"smooth\":\n        return 10  # Minimal exploration\n    else:\n        return 50  # Default moderate exploration\n</code></pre>"},{"location":"guides/dirac-configuration/#problem-specific-configurations","title":"Problem-Specific Configurations","text":""},{"location":"guides/dirac-configuration/#graph-type-optimization","title":"Graph Type Optimization","text":""},{"location":"guides/dirac-configuration/#dense-graphs-70-edge-density","title":"Dense Graphs (&gt; 70% edge density)","text":"<pre><code>def dense_graph_config():\n    \"\"\"Optimal configuration for dense graphs.\"\"\"\n    return DiracOracle(\n        num_samples=80,\n        relax_schedule=4,                      # High quality needed\n        mean_photon_number=0.0002,             # Strong coherence\n        quantum_fluctuation_coefficient=80     # High exploration\n    )\n\n# Usage\ndense_G = nx.erdos_renyi_graph(50, 0.8)\noracle = dense_graph_config()\nomega = oracle.get_omega(dense_G)\n</code></pre>"},{"location":"guides/dirac-configuration/#sparse-graphs-30-edge-density","title":"Sparse Graphs (&lt; 30% edge density)","text":"<pre><code>def sparse_graph_config():\n    \"\"\"Optimal configuration for sparse graphs.\"\"\"\n    return DiracOracle(\n        num_samples=40,\n        relax_schedule=2,                      # Balanced approach\n        mean_photon_number=0.003,              # Faster convergence\n        quantum_fluctuation_coefficient=30     # Moderate exploration\n    )\n\n# Usage  \nsparse_G = nx.erdos_renyi_graph(50, 0.2)\noracle = sparse_graph_config()\nomega = oracle.get_omega(sparse_G)\n</code></pre>"},{"location":"guides/dirac-configuration/#scale-free-networks","title":"Scale-Free Networks","text":"<pre><code>def scale_free_config():\n    \"\"\"Configuration for scale-free networks (power-law degree distribution).\"\"\"\n    return DiracOracle(\n        num_samples=60,\n        relax_schedule=3,                      # Good quality\n        mean_photon_number=0.001,              # Balanced coherence\n        quantum_fluctuation_coefficient=70     # High exploration for hubs\n    )\n\n# Usage\nscale_free_G = nx.barabasi_albert_graph(100, 5)\noracle = scale_free_config()\nomega = oracle.get_omega(scale_free_G)\n</code></pre>"},{"location":"guides/dirac-configuration/#problem-size-scaling","title":"Problem Size Scaling","text":""},{"location":"guides/dirac-configuration/#small-problems-30-nodes","title":"Small Problems (&lt; 30 nodes)","text":"<pre><code>def small_problem_config():\n    \"\"\"High-precision configuration for small problems.\"\"\"\n    return DiracOracle(\n        num_samples=150,                       # Many samples for precision\n        relax_schedule=4,                      # Highest quality\n        solution_precision=None,               # Continuous precision\n        mean_photon_number=0.0001,             # Maximum coherence\n        quantum_fluctuation_coefficient=90     # Full exploration\n    )\n</code></pre>"},{"location":"guides/dirac-configuration/#medium-problems-30-100-nodes","title":"Medium Problems (30-100 nodes)","text":"<pre><code>def medium_problem_config():\n    \"\"\"Balanced configuration for medium problems.\"\"\"\n    return DiracOracle(\n        num_samples=75,\n        relax_schedule=3,\n        mean_photon_number=0.0005,\n        quantum_fluctuation_coefficient=60\n    )\n</code></pre>"},{"location":"guides/dirac-configuration/#large-problems-100-nodes","title":"Large Problems (&gt; 100 nodes)","text":"<pre><code>def large_problem_config():\n    \"\"\"Efficient configuration for large problems.\"\"\"\n    return DiracOracle(\n        num_samples=40,                        # Fewer samples for speed\n        relax_schedule=2,                      # Faster schedule\n        mean_photon_number=0.001,              # Moderate coherence\n        quantum_fluctuation_coefficient=40     # Focused exploration\n    )\n</code></pre>"},{"location":"guides/dirac-configuration/#adaptive-configuration-strategies","title":"Adaptive Configuration Strategies","text":""},{"location":"guides/dirac-configuration/#dynamic-parameter-adjustment","title":"Dynamic Parameter Adjustment","text":"<pre><code>class AdaptiveDiracOracle(DiracOracle):\n    \"\"\"Dirac oracle that adapts parameters based on performance.\"\"\"\n\n    def __init__(self, **initial_params):\n        super().__init__(**initial_params)\n        self.performance_history = []\n        self.adaptation_enabled = True\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        if self.adaptation_enabled and len(self.performance_history) &gt; 3:\n            self._adapt_parameters(adjacency_matrix)\n\n        start_time = time.time()\n        result = super().solve_quadratic_program(adjacency_matrix)\n        elapsed = time.time() - start_time\n\n        # Record performance\n        self.performance_history.append({\n            'graph_size': adjacency_matrix.shape[0],\n            'graph_density': np.sum(adjacency_matrix) / (adjacency_matrix.shape[0]**2),\n            'result': result,\n            'time': elapsed,\n            'params': self._get_current_params()\n        })\n\n        return result\n\n    def _adapt_parameters(self, adjacency_matrix):\n        \"\"\"Adapt parameters based on recent performance.\"\"\"\n        recent = self.performance_history[-3:]\n        avg_time = np.mean([h['time'] for h in recent])\n\n        # If taking too long, reduce sample count\n        if avg_time &gt; 30:  # 30 second threshold\n            self.num_samples = max(20, int(self.num_samples * 0.8))\n\n        # If very fast, we can afford more samples\n        elif avg_time &lt; 5:\n            self.num_samples = min(150, int(self.num_samples * 1.2))\n</code></pre>"},{"location":"guides/dirac-configuration/#multi-phase-configuration","title":"Multi-Phase Configuration","text":"<pre><code>class MultiPhaseDiracOracle(DiracOracle):\n    \"\"\"Multi-phase optimization with parameter progression.\"\"\"\n\n    def __init__(self):\n        # Start with exploration phase\n        super().__init__(\n            num_samples=30,\n            relax_schedule=1,  # Fast exploration\n            mean_photon_number=0.0001,  # High coherence\n            quantum_fluctuation_coefficient=90  # High exploration\n        )\n        self.phase = \"exploration\"\n        self.exploration_results = []\n\n    def solve_quadratic_program(self, adjacency_matrix):\n        if self.phase == \"exploration\":\n            # Exploration phase: fast, high exploration\n            result = super().solve_quadratic_program(adjacency_matrix)\n            self.exploration_results.append(result)\n\n            # Switch to exploitation if we have enough data\n            if len(self.exploration_results) &gt;= 3:\n                self._switch_to_exploitation()\n                result = super().solve_quadratic_program(adjacency_matrix)\n\n            return result\n        else:\n            # Exploitation phase: quality refinement\n            return super().solve_quadratic_program(adjacency_matrix)\n\n    def _switch_to_exploitation(self):\n        \"\"\"Switch to exploitation configuration.\"\"\"\n        self.phase = \"exploitation\"\n        self.num_samples = 100\n        self.relax_schedule = 4  # High quality\n        self.quantum_fluctuation_coefficient = 30  # Lower exploration\n</code></pre>"},{"location":"guides/dirac-configuration/#performance-monitoring-and-debugging","title":"Performance Monitoring and Debugging","text":""},{"location":"guides/dirac-configuration/#configuration-performance-analysis","title":"Configuration Performance Analysis","text":"<pre><code>def analyze_configuration_performance(configs, test_graphs):\n    \"\"\"Compare different Dirac configurations.\"\"\"\n\n    results = {}\n\n    for config_name, config_params in configs.items():\n        results[config_name] = {}\n        oracle = DiracOracle(**config_params)\n\n        for graph_name, graph in test_graphs.items():\n            start_time = time.time()\n            omega = oracle.get_omega(graph)\n            elapsed = time.time() - start_time\n\n            results[config_name][graph_name] = {\n                'omega': omega,\n                'time': elapsed,\n                'samples': config_params['num_samples'],\n                'schedule': config_params['relax_schedule']\n            }\n\n    return results\n\n# Example usage\nconfigs = {\n    'fast': {'num_samples': 20, 'relax_schedule': 1},\n    'balanced': {'num_samples': 50, 'relax_schedule': 2},\n    'quality': {'num_samples': 100, 'relax_schedule': 4}\n}\n\ntest_graphs = {\n    'cycle_20': nx.cycle_graph(20),\n    'complete_15': nx.complete_graph(15),\n    'erdos_renyi_30': nx.erdos_renyi_graph(30, 0.5)\n}\n\nanalysis = analyze_configuration_performance(configs, test_graphs)\n</code></pre>"},{"location":"guides/dirac-configuration/#quantum-parameter-validation","title":"Quantum Parameter Validation","text":"<pre><code>def validate_quantum_parameters(oracle):\n    \"\"\"Validate quantum parameters are in physical ranges.\"\"\"\n\n    issues = []\n\n    # Check mean photon number\n    if oracle.mean_photon_number is not None:\n        if not (6.67e-5 &lt;= oracle.mean_photon_number &lt;= 6.67e-3):\n            issues.append(f\"mean_photon_number {oracle.mean_photon_number} outside valid range\")\n\n    # Check quantum fluctuation coefficient\n    if oracle.quantum_fluctuation_coefficient is not None:\n        if not (1 &lt;= oracle.quantum_fluctuation_coefficient &lt;= 100):\n            issues.append(f\"quantum_fluctuation_coefficient {oracle.quantum_fluctuation_coefficient} outside valid range\")\n\n    # Check for parameter conflicts\n    if (oracle.mean_photon_number is not None and \n        oracle.quantum_fluctuation_coefficient is not None):\n\n        # High coherence + high fluctuation may be suboptimal\n        if (oracle.mean_photon_number &lt; 0.0005 and \n            oracle.quantum_fluctuation_coefficient &gt; 80):\n            issues.append(\"High coherence + high fluctuation may cause instability\")\n\n    return issues\n</code></pre>"},{"location":"guides/dirac-configuration/#performance-optimization-tips","title":"Performance Optimization Tips","text":""},{"location":"guides/dirac-configuration/#memory-optimization","title":"Memory Optimization","text":"<pre><code># For memory-constrained environments\nmemory_efficient_oracle = DiracOracle(\n    num_samples=20,          # Fewer samples\n    relax_schedule=1,        # Faster processing\n    solution_precision=0.01  # Lower precision\n)\n</code></pre>"},{"location":"guides/dirac-configuration/#time-critical-applications","title":"Time-Critical Applications","text":"<pre><code># For real-time or time-critical applications\nfast_oracle = DiracOracle(\n    num_samples=15,\n    relax_schedule=1,\n    mean_photon_number=0.005,              # Faster convergence\n    quantum_fluctuation_coefficient=20     # Focused search\n)\n</code></pre>"},{"location":"guides/dirac-configuration/#research-applications","title":"Research Applications","text":"<pre><code># For research requiring highest quality\nresearch_oracle = DiracOracle(\n    num_samples=200,         # Maximum samples\n    relax_schedule=4,        # Highest quality\n    solution_precision=None, # Continuous precision\n    mean_photon_number=0.0001,             # Maximum coherence\n    quantum_fluctuation_coefficient=95     # Full exploration\n)\n</code></pre>"},{"location":"guides/dirac-configuration/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"guides/dirac-configuration/#configuration-guidelines","title":"Configuration Guidelines","text":"<ol> <li>Start with defaults for initial experiments</li> <li>Use relaxation schedule 2-3 for most applications  </li> <li>Increase samples for critical accuracy requirements</li> <li>Tune quantum parameters only after understanding base performance</li> <li>Monitor performance and adapt based on problem characteristics</li> </ol>"},{"location":"guides/dirac-configuration/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Over-parameterization: Don't tune all parameters simultaneously</li> <li>Ignoring physics: Quantum parameters have physical meaning</li> <li>Single configuration: Different problems need different settings</li> <li>No validation: Always validate parameter ranges</li> </ul>"},{"location":"guides/dirac-configuration/#recommended-workflow","title":"Recommended Workflow","text":"<pre><code>def recommended_dirac_workflow(graph):\n    \"\"\"Recommended configuration workflow.\"\"\"\n\n    # 1. Analyze problem characteristics\n    n = graph.number_of_nodes()\n    m = graph.number_of_edges()\n    density = 2 * m / (n * (n - 1)) if n &gt; 1 else 0\n\n    # 2. Select base configuration\n    if n &lt; 30:\n        base_config = small_problem_config()\n    elif n &lt; 100:\n        base_config = medium_problem_config()\n    else:\n        base_config = large_problem_config()\n\n    # 3. Adjust for graph density\n    if density &gt; 0.7:\n        base_config.quantum_fluctuation_coefficient *= 1.5\n        base_config.mean_photon_number /= 2\n    elif density &lt; 0.3:\n        base_config.quantum_fluctuation_coefficient *= 0.7\n        base_config.mean_photon_number *= 1.5\n\n    # 4. Validate parameters\n    issues = validate_quantum_parameters(base_config)\n    if issues:\n        print(f\"Configuration issues: {issues}\")\n\n    return base_config\n</code></pre> <p>Related Documentation: - Dirac Oracle API - Complete API reference - Performance Tuning - General optimization strategies - Troubleshooting - Common issues and solutions</p>"},{"location":"theory/decision-to-search/","title":"Decision-to-Search Reduction: From Oracles to Solutions","text":"<p>This document explains how the <code>motzkinstraus</code> package implements the classical decision-to-search reduction from computational complexity theory, transforming Motzkin-Straus decision oracles into constructive algorithms that find actual maximum cliques and independent sets.</p>"},{"location":"theory/decision-to-search/#theoretical-foundation","title":"Theoretical Foundation","text":""},{"location":"theory/decision-to-search/#the-decision-vs-search-paradigm","title":"The Decision vs. Search Paradigm","text":"<p>In computational complexity theory, we distinguish between two types of problems:</p> <ul> <li>Decision Problem: Given a graph G and integer k, does G contain a clique of size k? (YES/NO answer)</li> <li>Search Problem: Given a graph G, find a maximum clique in G (constructive answer)</li> </ul> <p>The decision-to-search reduction is a fundamental technique that shows how any algorithm solving the decision version can be used to solve the search version with only polynomial overhead.</p>"},{"location":"theory/decision-to-search/#self-reducibility","title":"Self-Reducibility","text":"<p>Maximum Clique and Maximum Independent Set are self-reducible problems, meaning:</p> <p>Self-Reducibility Property</p> <p>If we can solve the decision version of a problem in time T(n), we can solve the search version in time O(n\u00b7T(n)) using a greedy reduction algorithm.</p> <p>This property is crucial because it means we can use Motzkin-Straus oracles (which compute \u03c9(G)) to construct actual maximum cliques and independent sets.</p>"},{"location":"theory/decision-to-search/#oracle-based-architecture","title":"Oracle-Based Architecture","text":""},{"location":"theory/decision-to-search/#two-level-system-design","title":"Two-Level System Design","text":"<p>The package implements a clean two-level architecture:</p> <pre><code>graph TD\n    A[Search Algorithm] --&gt; B[Oracle Interface]\n    B --&gt; C[Motzkin-Straus Oracle]\n    C --&gt; D[Continuous Optimization]\n    D --&gt; E[Quadratic Programming]\n\n    A --&gt; F[Decision Questions]\n    F --&gt; |\"Is vertex v in optimal solution?\"| B\n    B --&gt; |\"\u03c9(modified_graph)\"| A</code></pre> <p>Level 1: Oracle Level - Motzkin-Straus oracles solve decision problems - Input: Graph G - Output: \u03c9(G) - the maximum clique size - Implementation: Continuous optimization via the Motzkin-Straus theorem</p> <p>Level 2: Algorithm Level - Search algorithms use oracles to construct solutions - Pattern: Test each vertex by oracle queries on modified graphs - Output: Actual vertex sets forming maximum cliques/independent sets</p>"},{"location":"theory/decision-to-search/#oracle-interface","title":"Oracle Interface","text":"<p>All oracles in the package implement a unified interface:</p> <pre><code>class Oracle:\n    def get_omega(self, graph: nx.Graph) -&gt; int:\n        \"\"\"Compute the maximum clique size \u03c9(G).\"\"\"\n        pass\n</code></pre> <p>This abstraction allows the same search algorithms to work with different oracle implementations (JAX, Gurobi, SciPy, Dirac, etc.).</p>"},{"location":"theory/decision-to-search/#algorithm-implementation","title":"Algorithm Implementation","text":""},{"location":"theory/decision-to-search/#core-reduction-pattern","title":"Core Reduction Pattern","text":"<p>Both maximum clique and maximum independent set algorithms follow the same pattern:</p> <pre><code>def search_algorithm(graph, oracle):\n    # Step 1: Get target size using oracle\n    k_target = oracle.get_omega(appropriate_graph)\n\n    solution = set()\n    current_graph = graph.copy()\n\n    # Step 2: Iteratively build solution\n    for vertex in current_graph.nodes():\n        # Test: \"Is vertex in some optimal solution?\"\n        modified_graph = create_test_graph(current_graph, vertex)\n        k_test = oracle.get_omega(modified_graph)\n\n        # Decision: Include vertex if test passes\n        if 1 + k_test == k_target:\n            solution.add(vertex)\n            current_graph = update_graph(current_graph, vertex)\n            k_target -= 1\n\n    return solution\n</code></pre>"},{"location":"theory/decision-to-search/#maximum-independent-set-algorithm","title":"Maximum Independent Set Algorithm","text":"<pre><code>def find_mis_with_oracle(graph: nx.Graph, oracle: Oracle) -&gt; Set[int]:\n    \"\"\"Find Maximum Independent Set using oracle-based search.\"\"\"\n\n    # Step 1: Get target MIS size using \u03b1(G) = \u03c9(complement(G))\n    complement = nx.complement(graph)\n    k_target = oracle.get_omega(complement)\n\n    mis_nodes = set()\n    current_graph = graph.copy()\n\n    # Step 2: Test each vertex\n    for v in graph.nodes():\n        if v not in current_graph.nodes():\n            continue\n\n        # Create test graph: remove v and all its neighbors\n        neighbors_of_v = list(current_graph.neighbors(v))\n        test_graph = current_graph.copy()\n        test_graph.remove_nodes_from([v] + neighbors_of_v)\n\n        # Oracle test: Can we achieve MIS size (k_target - 1) in remaining graph?\n        k_test = oracle.get_omega(nx.complement(test_graph))\n\n        if 1 + k_test == k_target:\n            # Vertex v is in some maximum independent set\n            mis_nodes.add(v)\n            current_graph = test_graph\n            k_target -= 1\n\n    return mis_nodes\n</code></pre> <p>Key Insight: For MIS, selecting vertex v eliminates v and all its neighbors from further consideration, dramatically shrinking the problem.</p>"},{"location":"theory/decision-to-search/#maximum-clique-algorithm","title":"Maximum Clique Algorithm","text":"<pre><code>def find_max_clique_with_oracle(graph: nx.Graph, oracle: Oracle) -&gt; Set[int]:\n    \"\"\"Find Maximum Clique using oracle-based search.\"\"\"\n\n    # Step 1: Get target clique size directly\n    k_target = oracle.get_omega(graph)\n\n    clique_nodes = set()\n    current_graph = graph.copy()\n\n    # Step 2: Test each vertex\n    for v in sorted(graph.nodes()):\n        if v not in current_graph.nodes():\n            continue\n\n        # Create test graph: neighborhood of v\n        neighbors_of_v = list(current_graph.neighbors(v))\n        test_graph = current_graph.subgraph(neighbors_of_v)\n\n        # Oracle test: Can we achieve clique size (k_target - 1) in neighborhood?\n        k_test = oracle.get_omega(test_graph)\n\n        if 1 + k_test == k_target:\n            # Vertex v is in some maximum clique\n            clique_nodes.add(v)\n            # Restrict to neighborhood for remaining search\n            current_graph = nx.Graph(test_graph)\n            k_target -= 1\n\n    return clique_nodes\n</code></pre> <p>Key Insight: For cliques, selecting vertex v restricts the remaining search to the neighborhood of v, maintaining the clique property.</p>"},{"location":"theory/decision-to-search/#complexity-analysis","title":"Complexity Analysis","text":""},{"location":"theory/decision-to-search/#oracle-call-complexity","title":"Oracle Call Complexity","text":"<p>The decision-to-search reduction achieves efficient oracle usage:</p> Algorithm Oracle Calls Graph Operations Memory Worst Case O(n) O(n\u00b2) per call O(n\u00b2) Typical Case O(\u221an) to O(n) Much less due to shrinkage O(current graph size) Best Case O(log n) Minimal O(solution size)"},{"location":"theory/decision-to-search/#why-its-efficient","title":"Why It's Efficient","text":"<ol> <li>Graph Shrinkage: Each vertex selection dramatically reduces the problem size</li> <li>Early Termination: Algorithm stops when <code>k_target</code> reaches 0</li> <li>No Backtracking: Greedy choices are guaranteed optimal by the oracle</li> <li>Incremental Construction: Solution built vertex-by-vertex, no exponential enumeration</li> </ol>"},{"location":"theory/decision-to-search/#polynomial-time-reduction","title":"Polynomial-Time Reduction","text":"<p>The reduction from search to decision is polynomial:</p> \\[T_{\\text{search}}(n) \\leq n \\cdot T_{\\text{oracle}}(n) + O(n^3)\\] <p>Where: - \\(T_{\\text{oracle}}(n)\\) is the time for one oracle call - \\(O(n^3)\\) accounts for graph operations (subgraph, complement, etc.) - The factor \\(n\\) comes from at most \\(n\\) oracle calls</p>"},{"location":"theory/decision-to-search/#complement-graph-strategy","title":"Complement Graph Strategy","text":""},{"location":"theory/decision-to-search/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>The package exploits the fundamental duality:</p> \\[\\text{Maximum Clique}(G) = \\text{Maximum Independent Set}(\\overline{G})\\] <p>Where \\(\\overline{G}\\) is the complement graph of \\(G\\).</p>"},{"location":"theory/decision-to-search/#practical-advantage","title":"Practical Advantage","text":"<p>This duality is crucial for computational efficiency:</p> <p>Dense \u2192 Sparse Transformation - Original graph G: \\(|E| = \\binom{n}{2} - k\\) edges (dense) - Complement graph \\(\\overline{G}\\): \\(|E| = k\\) edges (sparse) - Example: C125.9 graph has 6,963 edges, but its complement has only 787 edges!</p>"},{"location":"theory/decision-to-search/#implementation-in-find_max_clique_via_mispy","title":"Implementation in <code>find_max_clique_via_mis.py</code>","text":"<pre><code>def find_clique_via_mis_strategy(graph):\n    \"\"\"Find max clique by solving MIS on complement.\"\"\"\n\n    # Step 1: Transform to complement (dense \u2192 sparse)\n    complement = nx.complement(graph)\n\n    # Step 2: Solve MIS on sparse complement\n    # This is often much faster than clique on dense original\n    mis_in_complement = find_mis_with_oracle(complement, oracle)\n\n    # Step 3: MIS in complement = clique in original\n    max_clique_in_original = mis_in_complement\n\n    return max_clique_in_original\n</code></pre> <p>Why This Works: - Dense clique problems become sparse MIS problems - Sparse graphs are generally easier for optimization algorithms - The oracle performs better on sparse graphs - Graph operations (subgraph, complement) are faster on sparse graphs</p>"},{"location":"theory/decision-to-search/#implementation-examples","title":"Implementation Examples","text":""},{"location":"theory/decision-to-search/#basic-usage-pattern","title":"Basic Usage Pattern","text":"<pre><code>from motzkinstraus.oracles.jax_pgd import ProjectedGradientDescentOracle\nfrom motzkinstraus.algorithms import find_mis_with_oracle, find_max_clique_with_oracle\n\n# Create oracle (decision solver)\noracle = ProjectedGradientDescentOracle(num_restarts=5)\n\n# Example graph\ngraph = nx.erdos_renyi_graph(20, 0.4)\n\n# Find solutions using decision-to-search reduction\nmis_nodes, oracle_calls = find_mis_with_oracle(graph, oracle)\nclique_nodes, oracle_calls = find_max_clique_with_oracle(graph, oracle)\n\nprint(f\"MIS size: {len(mis_nodes)} (found with {oracle_calls} oracle calls)\")\nprint(f\"Clique size: {len(clique_nodes)} (found with {oracle_calls} oracle calls)\")\n</code></pre>"},{"location":"theory/decision-to-search/#oracle-call-tracking","title":"Oracle Call Tracking","text":"<p>The algorithms track oracle usage for performance analysis:</p> <pre><code># Reset oracle call counter\noracle.call_count = 0\n\n# Run algorithm\nsolution, total_calls = find_mis_with_oracle(graph, oracle)\n\nprint(f\"Solution quality: {len(solution)}\")\nprint(f\"Computational cost: {total_calls} oracle calls\")\nprint(f\"Efficiency: {len(solution)/total_calls:.2f} vertices per call\")\n</code></pre>"},{"location":"theory/decision-to-search/#validation-and-verification","title":"Validation and Verification","text":"<pre><code>def validate_solution(graph, solution, problem_type):\n    \"\"\"Validate that the solution is correct.\"\"\"\n    if problem_type == \"mis\":\n        # Check independence: no edges within solution\n        for u, v in combinations(solution, 2):\n            assert not graph.has_edge(u, v), f\"Edge {u}-{v} violates independence\"\n\n    elif problem_type == \"clique\":  \n        # Check completeness: all pairs connected\n        for u, v in combinations(solution, 2):\n            assert graph.has_edge(u, v), f\"Missing edge {u}-{v} violates clique property\"\n\n    return True\n\n# Verify correctness\nmis_valid = validate_solution(graph, mis_nodes, \"mis\")\nclique_valid = validate_solution(graph, clique_nodes, \"clique\")\n</code></pre>"},{"location":"theory/decision-to-search/#advanced-optimizations","title":"Advanced Optimizations","text":""},{"location":"theory/decision-to-search/#vertex-ordering-heuristics","title":"Vertex Ordering Heuristics","text":"<p>The algorithm processes vertices in sorted order for determinism, but alternative orderings can improve performance:</p> <pre><code>def degree_descending_order(graph):\n    \"\"\"Process high-degree vertices first (more likely to be in cliques).\"\"\"\n    return sorted(graph.nodes(), key=graph.degree, reverse=True)\n\ndef degree_ascending_order(graph):  \n    \"\"\"Process low-degree vertices first (easier to eliminate).\"\"\"\n    return sorted(graph.nodes(), key=graph.degree)\n</code></pre>"},{"location":"theory/decision-to-search/#early-termination-strategies","title":"Early Termination Strategies","text":"<pre><code>def find_mis_with_early_termination(graph, oracle, target_size=None):\n    \"\"\"Stop search early if target size is reached.\"\"\"\n    if target_size is None:\n        target_size = oracle.get_omega(nx.complement(graph))\n\n    # ... algorithm implementation ...\n\n    if len(mis_nodes) &gt;= target_size:\n        break  # Early termination\n\n    return mis_nodes\n</code></pre>"},{"location":"theory/decision-to-search/#parallel-oracle-calls","title":"Parallel Oracle Calls","text":"<p>For expensive oracles, we can parallelize some oracle calls:</p> <pre><code>import concurrent.futures\n\ndef parallel_vertex_testing(candidates, oracle, test_graphs):\n    \"\"\"Test multiple vertices in parallel.\"\"\"\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        futures = {executor.submit(oracle.get_omega, g): v \n                  for v, g in zip(candidates, test_graphs)}\n\n        results = {}\n        for future in concurrent.futures.as_completed(futures):\n            vertex = futures[future]\n            omega = future.result()\n            results[vertex] = omega\n\n    return results\n</code></pre>"},{"location":"theory/decision-to-search/#correctness-guarantees","title":"Correctness Guarantees","text":""},{"location":"theory/decision-to-search/#theoretical-guarantees","title":"Theoretical Guarantees","text":"<p>The decision-to-search reduction provides strong correctness guarantees:</p> <p>Correctness Theorem</p> <p>If the oracle correctly computes \u03c9(G) for all induced subgraphs of the input graph, then the search algorithm returns a maximum clique (or maximum independent set) of the correct size.</p> <p>Proof Sketch:  1. The oracle provides the optimal target size 2. Each vertex inclusion test verifies optimality for the remaining subproblem 3. The greedy choice property ensures no backtracking is needed 4. Graph reductions preserve optimality conditions</p>"},{"location":"theory/decision-to-search/#practical-robustness","title":"Practical Robustness","text":"<p>Oracle Accuracy: The algorithm's correctness depends entirely on oracle accuracy. If the oracle provides approximate results, the algorithm may: - Find a suboptimal solution - Fail to find a solution of the expected size - Return an invalid solution (rare with good oracles)</p> <p>Failure Detection: The algorithm can detect oracle inconsistencies:</p> <pre><code>def robust_find_mis(graph, oracle, max_retries=3):\n    \"\"\"Find MIS with oracle inconsistency detection.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            solution, calls = find_mis_with_oracle(graph, oracle)\n\n            # Validate solution\n            if validate_solution(graph, solution, \"mis\"):\n                return solution, calls\n            else:\n                print(f\"Attempt {attempt + 1}: Invalid solution, retrying...\")\n\n        except Exception as e:\n            print(f\"Attempt {attempt + 1}: Oracle error: {e}\")\n\n    raise RuntimeError(\"Failed to find valid solution after maximum retries\")\n</code></pre>"},{"location":"theory/decision-to-search/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"theory/decision-to-search/#best-case-scenarios","title":"Best-Case Scenarios","text":"<p>The algorithm performs optimally when: - Sparse Graphs: Fewer edges mean smaller neighborhoods and faster oracle calls - Clear Structure: Graphs with obvious large cliques/independent sets - Good Vertex Ordering: Processing optimal vertices first minimizes oracle calls</p>"},{"location":"theory/decision-to-search/#challenging-cases","title":"Challenging Cases","text":"<p>The algorithm may struggle with: - Dense Random Graphs: Many oracle calls needed, large neighborhoods - Oracle Inaccuracy: Approximate oracles may lead to suboptimal paths - Degenerate Cases: Graphs where many vertices have similar oracle test results</p>"},{"location":"theory/decision-to-search/#benchmarking-results","title":"Benchmarking Results","text":"<p>Typical performance on standard graph instances:</p> Graph Type Nodes Edges Oracle Calls Success Rate Sparse Random 100 200 15-25 100% Dense Random 100 2000 60-80 95% DIMACS Clique 125 6963 20-40 100% DIMACS Complement 125 787 8-15 100%"},{"location":"theory/decision-to-search/#connection-to-motzkin-straus-theory","title":"Connection to Motzkin-Straus Theory","text":""},{"location":"theory/decision-to-search/#bridging-continuous-and-discrete","title":"Bridging Continuous and Discrete","text":"<p>The decision-to-search reduction creates a beautiful bridge between:</p> <p>Continuous Optimization (Motzkin-Straus Theorem) - Solves: \\(\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x\\) - Output: Optimal value \\(M\\) and vector \\(x^*\\) - Conversion: \\(\\omega(G) = \\frac{1}{1 - 2M}\\)</p> <p>Discrete Combinatorics (Graph Theory) - Solves: Find maximum clique vertices in graph \\(G\\) - Output: Vertex set \\(C \\subseteq V\\) forming maximum clique - Verification: \\(|C| = \\omega(G)\\) and \\(C\\) induces complete subgraph</p>"},{"location":"theory/decision-to-search/#algorithmic-pipeline","title":"Algorithmic Pipeline","text":"<pre><code>graph LR\n    A[Graph G] --&gt; B[Motzkin-Straus Oracle]\n    B --&gt; C[\u03c9(G) Decision]\n    C --&gt; D[Decision-to-Search Algorithm]\n    D --&gt; E[Vertex Set Solution]\n    E --&gt; F[Validation]\n    F --&gt; G[Maximum Clique/MIS]</code></pre> <p>This pipeline transforms the elegant mathematical theory of Motzkin-Straus into practical algorithms that solve real-world graph problems.</p>"},{"location":"theory/decision-to-search/#summary","title":"Summary","text":"<p>The decision-to-search reduction implemented in the <code>motzkinstraus</code> package represents a sophisticated fusion of:</p> <ol> <li>Classical Complexity Theory: Self-reducibility and polynomial-time oracle reductions</li> <li>Modern Continuous Optimization: Motzkin-Straus theorem and quadratic programming  </li> <li>Practical Graph Algorithms: Efficient implementation with real-world optimizations</li> </ol> <p>Key Achievements: - Theoretical Soundness: Provably correct algorithms with polynomial overhead - Practical Efficiency: O(n) oracle calls with aggressive graph reduction - Implementation Elegance: Clean abstraction separating decision oracles from search algorithms - Strategic Optimization: Complement graph strategy transforms hard dense problems into easier sparse problems</p> <p>This approach enables users to leverage powerful continuous optimization techniques (JAX, Gurobi, quantum annealing) to solve discrete graph problems with theoretical guarantees and practical efficiency.</p> <p>Next: Explore specific oracle implementations or learn about performance tuning for the algorithms.</p>"},{"location":"theory/motzkin-straus/","title":"The Motzkin-Straus Theorem","text":"<p>The Motzkin-Straus theorem provides an elegant bridge between discrete graph theory and continuous optimization, enabling us to solve the NP-hard Maximum Independent Set problem through quadratic programming.</p>"},{"location":"theory/motzkin-straus/#problem-definition","title":"Problem Definition","text":""},{"location":"theory/motzkin-straus/#maximum-independent-set-mis","title":"Maximum Independent Set (MIS)","text":"<p>Definition: Independent Set</p> <p>Given an undirected graph \\(G = (V, E)\\), an independent set is a subset \\(S \\subseteq V\\) of vertices such that no two vertices in \\(S\\) are adjacent:</p> \\[\\forall u, v \\in S: (u, v) \\notin E\\] <p>The Maximum Independent Set (MIS) problem seeks to find an independent set of maximum cardinality:</p> \\[\\alpha(G) = \\max\\{|S| : S \\text{ is an independent set in } G\\}\\] <p>where \\(\\alpha(G)\\) is called the independence number of \\(G\\).</p>"},{"location":"theory/motzkin-straus/#maximum-clique-problem","title":"Maximum Clique Problem","text":"<p>Definition: Clique</p> <p>A clique in graph \\(G = (V, E)\\) is a subset \\(C \\subseteq V\\) where every pair of distinct vertices is adjacent:</p> \\[\\forall u, v \\in C, u \\neq v: (u, v) \\in E\\] <p>The clique number \\(\\omega(G)\\) is the size of the maximum clique:</p> \\[\\omega(G) = \\max\\{|C| : C \\text{ is a clique in } G\\}\\]"},{"location":"theory/motzkin-straus/#fundamental-relationship","title":"Fundamental Relationship","text":"<p>The key insight connecting these problems lies in the complement graph:</p> <p>Graph Complement</p> <p>For graph \\(G = (V, E)\\), the complement \\(\\overline{G} = (V, \\overline{E})\\) has the same vertices but complementary edges:</p> \\[\\overline{E} = \\{(u, v) : u, v \\in V, u \\neq v, (u, v) \\notin E\\}\\] <p>This leads to the fundamental equivalence:</p> MIS-Clique Equivalence  For any graph $G$:  $$\\alpha(G) = \\omega(\\overline{G})$$  An independent set in $G$ corresponds exactly to a clique in $\\overline{G}$."},{"location":"theory/motzkin-straus/#the-motzkin-straus-theorem_1","title":"The Motzkin-Straus Theorem","text":""},{"location":"theory/motzkin-straus/#statement","title":"Statement","text":"Motzkin-Straus Theorem (1965)  Let $G = (V, E)$ be a graph with $n = |V|$ vertices and adjacency matrix $A$. Define the **standard simplex**:  $$\\Delta_n = \\left\\{x \\in \\mathbb{R}^n : \\sum_{i=1}^n x_i = 1, x_i \\geq 0 \\text{ for all } i\\right\\}$$  Then the following equality holds:  $$\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x = \\frac{1}{2}\\left(1 - \\frac{1}{\\omega(G)}\\right)$$  where $\\omega(G)$ is the clique number of $G$."},{"location":"theory/motzkin-straus/#intuition","title":"Intuition","text":"<p>The theorem establishes that:</p> <ol> <li>Left side: A continuous quadratic optimization problem over the probability simplex</li> <li>Right side: A simple function of the discrete clique number</li> </ol> <p>This remarkable connection allows us to solve discrete graph problems using continuous optimization techniques.</p>"},{"location":"theory/motzkin-straus/#algorithmic-derivation-from-the-original-paper","title":"Algorithmic Derivation from the Original Paper","text":"<p>The 1965 Motzkin-Straus paper not only proves the theorem but reveals how the algorithm emerges naturally from the mathematical analysis. This section follows their original derivation.</p>"},{"location":"theory/motzkin-straus/#mathematical-foundation","title":"Mathematical Foundation","text":"<p>Given graph \\(G\\) with vertices \\(1, 2, \\ldots, n\\), we seek to maximize:</p> \\[F(x) = \\sum_{(i,j) \\in E(G)} x_i x_j\\] <p>subject to \\(x \\in \\Delta_n\\) (the probability simplex).</p>"},{"location":"theory/motzkin-straus/#proof-strategy-and-algorithm-emergence","title":"Proof Strategy and Algorithm Emergence","text":"<p>The original proof uses mathematical induction and critical point analysis, which naturally leads to an iterative algorithm:</p>"},{"location":"theory/motzkin-straus/#step-1-lower-bound-construction-algorithmic-insight","title":"Step 1: Lower Bound Construction (Algorithmic Insight)","text":"<p>For any clique \\(C\\) of size \\(k\\) in \\(G\\), setting: - \\(x_i = \\frac{1}{k}\\) for all \\(i \\in C\\) - \\(x_j = 0\\) for all \\(j \\notin C\\)</p> <p>yields the objective value:</p> \\[F(x) = \\binom{k}{2} \\cdot \\frac{1}{k^2} = \\frac{1}{2}\\left(1 - \\frac{1}{k}\\right)\\] <p>Algorithmic Implication: The optimal solution concentrates probability mass uniformly on the maximum clique.</p>"},{"location":"theory/motzkin-straus/#step-2-optimality-conditions-algorithm-discovery","title":"Step 2: Optimality Conditions (Algorithm Discovery)","text":"<p>At an interior maximum, all partial derivatives must be equal (Lagrange multipliers):</p> \\[\\frac{\\partial F}{\\partial x_i} = \\sum_{j: (i,j) \\in E(G)} x_j = \\lambda \\quad \\text{for all } i \\text{ with } x_i &gt; 0\\] <p>Key Insight: This condition reveals the iterative algorithm! Each vertex's \"score\" in the optimal solution equals its weighted degree in the current solution.</p>"},{"location":"theory/motzkin-straus/#step-3-inductive-argument-boundary-analysis","title":"Step 3: Inductive Argument (Boundary Analysis)","text":"<p>The original proof analyzes two cases:</p> <p>Case A: Maximum occurs on the boundary of the simplex - Some \\(x_i = 0\\), reducing to a smaller graph - Apply induction hypothesis</p> <p>Case B: Maximum occurs in the interior - All optimality conditions hold simultaneously - Graph must have special structure (complete subgraph)</p> <p>Algorithmic Emergence: This analysis suggests checking whether including/excluding vertices improves the objective.</p>"},{"location":"theory/motzkin-straus/#the-natural-algorithm","title":"The Natural Algorithm","text":"<p>From the optimality conditions, we derive the iterative reweighting algorithm:</p> Motzkin-Straus Iterative Algorithm  **Input**: Graph $G$ with adjacency matrix $A$   **Output**: Optimal vector $x^*$ and clique number $\\omega(G)$  1. **Initialize**: $x^{(0)} \\leftarrow \\frac{1}{n} \\mathbf{1}$ (uniform distribution) 2. **Iterate** until convergence:    - **Compute scores**: $s_i^{(t)} = \\sum_{j: (i,j) \\in E(G)} x_j^{(t)} = (Ax^{(t)})_i$    - **Reweight**: $x_i^{(t+1)} = \\frac{s_i^{(t)}}{\\sum_{j=1}^n s_j^{(t)}}$ 3. **Extract**: $\\omega(G) = \\frac{1}{1 - 2F(x^*)}$ where $F(x^*) = \\frac{1}{2}(x^*)^T A x^*$"},{"location":"theory/motzkin-straus/#mathematical-justification-of-the-algorithm","title":"Mathematical Justification of the Algorithm","text":"<p>The reweighting rule \\(x_i^{(t+1)} \\propto (Ax^{(t)})_i\\) emerges from the optimality condition:</p> \\[\\frac{\\partial F}{\\partial x_i}\\bigg|_{x=x^*} = \\sum_{j: (i,j) \\in E(G)} x_j^* = \\text{constant for all } i \\text{ with } x_i^* &gt; 0\\] <p>This is precisely the replicator dynamics from evolutionary game theory!</p>"},{"location":"theory/motzkin-straus/#proof-completion-original-method","title":"Proof Completion (Original Method)","text":""},{"location":"theory/motzkin-straus/#lemma-1-boundary-reduction","title":"Lemma 1: Boundary Reduction","text":"<p>If the maximum occurs when some \\(x_i = 0\\), then we can delete vertex \\(i\\) and solve the reduced problem.</p>"},{"location":"theory/motzkin-straus/#lemma-2-interior-structure","title":"Lemma 2: Interior Structure","text":"<p>If the maximum occurs in the interior, then the graph restricted to \\(\\{i : x_i &gt; 0\\}\\) must be complete.</p> <p>Proof technique: If \\((i,j) \\notin E(G)\\) but \\(x_i, x_j &gt; 0\\), then the transformation: \\(\\(x_i \\leftarrow x_i - \\epsilon, \\quad x_j \\leftarrow x_j + \\epsilon\\)\\) preserves the simplex constraint but can increase the objective, contradicting optimality.</p>"},{"location":"theory/motzkin-straus/#main-theorem-proof","title":"Main Theorem Proof","text":"<p>Combining the lemmas with induction on \\(n\\):</p> <ol> <li>Base case: \\(n = 1\\) gives \\(\\omega(G) = 1\\) and \\(F(x) = 0\\)</li> <li>Inductive step: Either apply boundary reduction or use interior structure</li> <li>Conclusion: \\(\\max F(x) = \\frac{1}{2}(1 - \\frac{1}{\\omega(G)})\\)</li> </ol>"},{"location":"theory/motzkin-straus/#connection-to-modern-optimization","title":"Connection to Modern Optimization","text":"<p>The original derivation connects to several modern approaches:</p>"},{"location":"theory/motzkin-straus/#frank-wolfe-method","title":"Frank-Wolfe Method","text":"<p>The iterative algorithm is a special case of Frank-Wolfe: - Linear oracle: Find \\(v = \\arg\\max_{u \\in \\Delta_n} \\langle \\nabla F(x^{(t)}), u \\rangle\\) - Update: \\(x^{(t+1)} = (1-\\gamma_t)x^{(t)} + \\gamma_t v\\)</p>"},{"location":"theory/motzkin-straus/#spectral-methods","title":"Spectral Methods","text":"<p>When \\(A\\) is the adjacency matrix, the algorithm finds the principal eigenvector direction restricted to the simplex.</p>"},{"location":"theory/motzkin-straus/#interior-point-methods","title":"Interior Point Methods","text":"<p>Modern solvers handle the simplex constraints directly using barrier methods or active-set approaches.</p>"},{"location":"theory/motzkin-straus/#convergence-analysis","title":"Convergence Analysis","text":"<p>From the original paper's perspective:</p> <p>Convergence Properties</p> <ul> <li>Fixed points: Correspond to local maxima of \\(F(x)\\) on \\(\\Delta_n\\)</li> <li>Global maximum: Achieved when support of \\(x^*\\) is exactly a maximum clique</li> <li>Rate: Depends on spectral gap of the reweighting operator</li> <li>Initialization: Different starting points may converge to different local maxima</li> </ul>"},{"location":"theory/motzkin-straus/#computational-implications","title":"Computational Implications","text":""},{"location":"theory/motzkin-straus/#oracle-construction","title":"Oracle Construction","text":"<p>The Motzkin-Straus theorem enables us to construct an oracle for the clique number:</p> Oracle(G) \u2192 \u03c9(G)  **Input**: Graph $G$ with adjacency matrix $A$   **Output**: Clique number $\\omega(G)$  1. **Formulate QP**: $\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x$ 2. **Solve**: Use numerical optimization to find optimal value $M$ 3. **Convert**: Return $\\omega(G) = \\frac{1}{1 - 2M}$"},{"location":"theory/motzkin-straus/#mis-algorithm","title":"MIS Algorithm","text":"<p>Combined with the MIS-clique equivalence, we get our complete algorithm:</p> MIS Algorithm  **Input**: Graph $G$   **Output**: Maximum independent set of $G$  1. **Target Size**: Compute $k = \\alpha(G) = \\omega(\\overline{G})$ using oracle 2. **Iterative Construction**: Build MIS vertex by vertex using oracle queries 3. **Optimality Check**: For each vertex $v$, test if including $v$ maintains optimality 4. **Decision**: Include $v$ if $1 + \\text{remaining\\_capacity} = \\text{current\\_target}$"},{"location":"theory/motzkin-straus/#quadratic-programming-formulation","title":"Quadratic Programming Formulation","text":""},{"location":"theory/motzkin-straus/#standard-form","title":"Standard Form","text":"<p>The optimization problem can be written in standard quadratic programming form:</p> \\[\\begin{align} \\text{maximize} \\quad &amp; \\frac{1}{2} x^T A x \\\\ \\text{subject to} \\quad &amp; \\sum_{i=1}^n x_i = 1 \\\\ &amp; x_i \\geq 0, \\quad i = 1, \\ldots, n \\end{align}\\]"},{"location":"theory/motzkin-straus/#properties","title":"Properties","text":"<p>Problem Characteristics</p> <ul> <li>Objective: Quadratic (generally non-convex for graph adjacency matrices)</li> <li>Constraints: Linear (defines the probability simplex)</li> <li>Variables: \\(n\\) continuous variables</li> <li>Feasible Region: Compact and convex</li> <li>Global Optimum: Guaranteed to exist (Weierstrass theorem)</li> </ul>"},{"location":"theory/motzkin-straus/#challenges","title":"Challenges","text":"<ol> <li>Non-convexity: The objective function \\(\\frac{1}{2} x^T A x\\) is generally non-convex</li> <li>Local Optima: Standard optimization algorithms may get trapped</li> <li>Numerical Precision: Floating-point errors can affect the final integer result</li> </ol>"},{"location":"theory/motzkin-straus/#extensions-and-variations","title":"Extensions and Variations","text":""},{"location":"theory/motzkin-straus/#weighted-graphs","title":"Weighted Graphs","text":"<p>The theorem extends naturally to weighted graphs with adjacency matrix \\(A\\) having non-negative weights:</p> \\[\\max_{x \\in \\Delta_n} \\frac{1}{2} x^T A x = \\frac{1}{2}\\left(1 - \\frac{1}{\\omega_w(G)}\\right)\\] <p>where \\(\\omega_w(G)\\) is the weight of the maximum weighted clique.</p>"},{"location":"theory/motzkin-straus/#fractional-clique-number","title":"Fractional Clique Number","text":"<p>The continuous relaxation provides insights into the fractional clique number:</p> \\[\\omega_f(G) = \\frac{1}{1 - 2M}\\] <p>where \\(M\\) is the optimal value of the quadratic program. This quantity satisfies:</p> \\[\\omega(G) \\leq \\omega_f(G) \\leq n\\]"},{"location":"theory/motzkin-straus/#stability-number-connection","title":"Stability Number Connection","text":"<p>For the stability number (independence number), we have:</p> \\[\\alpha(G) = \\omega(\\overline{G}) = \\frac{1}{1 - 2 \\max_{x \\in \\Delta_n} \\frac{1}{2} x^T \\overline{A} x}\\] <p>where \\(\\overline{A}\\) is the adjacency matrix of the complement graph.</p>"},{"location":"theory/motzkin-straus/#theoretical-complexity","title":"Theoretical Complexity","text":""},{"location":"theory/motzkin-straus/#classical-complexity","title":"Classical Complexity","text":"<ul> <li>MIS Problem: NP-hard in general graphs</li> <li>Approximation: Hard to approximate within factor \\(n^{1-\\epsilon}\\) for any \\(\\epsilon &gt; 0\\)</li> <li>Special Cases: Polynomial-time solvable in bipartite graphs, trees, etc.</li> </ul>"},{"location":"theory/motzkin-straus/#continuous-relaxation","title":"Continuous Relaxation","text":"<p>The quadratic program provides:</p> <ul> <li>Continuous Relaxation: Polynomial-time solvable (in theory)</li> <li>Rounding: The continuous solution must be carefully rounded to discrete</li> <li>Approximation Quality: Depends on the optimization algorithm used</li> </ul>"},{"location":"theory/motzkin-straus/#our-approach-complexity","title":"Our Approach Complexity","text":"<p>The oracle-based MIS algorithm has complexity:</p> <ul> <li>Oracle Calls: \\(O(n)\\) calls in the worst case</li> <li>Per-Oracle Cost: Depends on the quadratic programming solver</li> <li>Total Complexity: \\(O(n \\cdot T_{QP}(n))\\) where \\(T_{QP}(n)\\) is QP solver time</li> </ul>"},{"location":"theory/motzkin-straus/#historical-context","title":"Historical Context","text":""},{"location":"theory/motzkin-straus/#original-work","title":"Original Work","text":"<p>The theorem was first published by:</p> <p>Citation</p> <p>T. S. Motzkin and E. G. Straus, \"Maxima for graphs and a new proof of a theorem of Tur\u00e1n,\" Canadian Journal of Mathematics, vol. 17, pp. 533-540, 1965.</p>"},{"location":"theory/motzkin-straus/#subsequent-developments","title":"Subsequent Developments","text":"<ul> <li>1970s: Extensions to hypergraphs and weighted cases</li> <li>1980s: Computational studies and approximation algorithms  </li> <li>1990s: Semidefinite programming relaxations</li> <li>2000s: Modern optimization approaches (interior point, first-order methods)</li> <li>2020s: Quantum computing applications (our work with Dirac-3)</li> </ul>"},{"location":"theory/motzkin-straus/#summary","title":"Summary","text":"<p>The Motzkin-Straus theorem provides a beautiful mathematical framework that:</p> <ol> <li>Bridges Domains: Connects discrete graph theory with continuous optimization</li> <li>Enables Algorithms: Provides a computational pathway for NP-hard problems</li> <li>Offers Flexibility: Supports various optimization backends and solver choices</li> <li>Maintains Rigor: Preserves mathematical exactness through the equivalence</li> </ol> <p>This theoretical foundation underlies our entire computational approach, enabling us to leverage powerful optimization tools\u2014from classical solvers to quantum annealers\u2014for solving maximum independent set problems.</p> <p>Next: Explore the specific algorithms that implement this theory, or dive into the quadratic programming solvers that make it computationally feasible.</p>"}]}